var data = {"count":20,"start":0,"total":7831,"books":[{"rating":{"max":10,"numRaters":245,"average":"9.3","min":0},"subtitle":"Java","author":["Joshua Bloch"],"pubdate":"2008-05-28","tags":[{"count":179,"name":"java","title":"java"},{"count":63,"name":"Java","title":"Java"},{"count":58,"name":"programming","title":"programming"},{"count":52,"name":"编程","title":"编程"},{"count":43,"name":"计算机","title":"计算机"},{"count":36,"name":"Effective","title":"Effective"},{"count":31,"name":"软件开发","title":"软件开发"},{"count":30,"name":"程序设计","title":"程序设计"}],"origin_title":"","image":"https://img3.doubanio.com\/mpic\/s3259732.jpg","binding":"Paperback","translator":[],"catalog":"Foreword\nPreface\nAcknowledgments\n1 Introduction\n2 Creating and Destroying Objects\nItem 1: Consider static factory methods instead of constructors\nItem 2: Consider a builder when faced with many constructor parameters\nItem 3: Enforce the singleton property with a private constructor or an enum type\nItem 4: Enforce noninstantiability with a private constructor\nItem 5: Avoid creating unnecessary objects\nItem 6: Eliminate obsolete object references\nItem 7: Avoid finalizers\n3 Methods Common to All Objects\nItem 8: Obey the general contract when overriding equals\nItem 9: Always override hashCode when you override equals\nItem 10: Always override toString\nItem 11: Override clone judiciously\nItem 12: Consider implementing Comparable\n4 Classes and Interfaces\nItem 13: Minimize the accessibility of classes and members\nItem 14: In public classes, use accessor methods, not public fields\nItem 15: Minimize mutability\nItem 16: Favor composition over inheritance\nItem 17: Design and document for inheritance or else prohibit it\nItem 18: Prefer interfaces to abstract classes\nItem 19: Use interfaces only to define types\nItem 20: Prefer class hierarchies to tagged classes\nItem 21: Use function objects to represent strategies\nItem 22: Favor static member classes over nonstatic\n5 Generics\nItem 23: Don't use raw types in new code\nItem 24: Eliminate unchecked warnings\nItem 25: Prefer lists to arrays\nItem 26: Favor generic types\nItem 27: Favor generic methods\nItem 28: Use bounded wildcards to increase API flexibility\nItem 29: Consider typesafe heterogeneous containers\n6 Enums and Annotations\nItem 30: Use enums instead of int constants\nItem 31: Use instance fields instead of ordinals\nItem 32: Use EnumSet instead of bit fields\nItem 33: Use EnumMap instead of ordinal indexing\nItem 34: Emulate extensible enums with interfaces\nItem 35: Prefer annotations to naming patterns\nItem 36: Consistently use the Override annotation\nItem 37: Use marker interfaces to define types\n7 Methods\nItem 38: Check parameters for validity\nItem 39: Make defensive copies when needed\nItem 40: Design method signatures carefully\nItem 41: Use overloading judiciously\nItem 42: Use varargs judiciously\nItem 43: Return empty arrays or collections, not nulls\nItem 44: Write doc comments for all exposed API elements\n8 General Programming\nItem 45: Minimize the scope of local variables\nItem 46: Prefer for-each loops to traditional for loops\nItem 47: Know and use the libraries\nItem 48: Avoid float and double if exact answers are required\nItem 49: Prefer primitive types to boxed primitives\nItem 50: Avoid strings where other types are more appropriate\nItem 51: Beware the performance of string concatenation\nItem 52: Refer to objects by their interfaces\nItem 53: Prefer interfaces to reflection\nItem 54: Use native methods judiciously\nItem 55: Optimize judiciously\nItem 56: Adhere to generally accepted naming conventions\n9 Exceptions\nItem 57: Use exceptions only for exceptional conditions\nItem 58: Use checked exceptions for recoverable conditions and runtime exceptions for programming errors\nItem 59: Avoid unnecessary use of checked exceptions\nItem 60: Favor the use of standard exceptions\nItem 61: Throw exceptions appropriate to the abstraction\nItem 62: Document all exceptions thrown by each method\nItem 63: Include failure-capture information in detail messages\nItem 64: Strive for failure atomicity\nItem 65: Don't ignore exceptions\n10 Concurrency\nItem 66: Synchronize access to shared mutable data\nItem 67: Avoid excessive synchronization\nItem 68: Prefer executors and tasks to threads\nItem 69: Prefer concurrency utilities to wait and notify\nItem 70: Document thread safety\nItem 71: Use lazy initialization judiciously\nItem 72: Don't depend on the thread scheduler\nItem 73: Avoid thread groups\n11 Serialization\nItem 74: Implement Serializable judiciously\nItem 75: Consider using a custom serialized form\nItem 76: Write readObject methods defensively\nItem 77: For instance control, prefer enum types to readResolve\nItem 78: Consider serialization proxies instead of serialized instances\nAppendix: Items Corresponding to First Edition\nReferences\nIndex","pages":"346","images":{"small":"https://img3.doubanio.com\/spic\/s3259732.jpg","large":"https://img3.doubanio.com\/lpic\/s3259732.jpg","medium":"https://img3.doubanio.com\/mpic\/s3259732.jpg"},"alt":"https:\/\/book.douban.com\/subject\/2696119\/","id":"2696119","publisher":"Addison-Wesley","isbn10":"0321356683","isbn13":"9780321356680","title":"Effective Java: Second Edition","url":"https:\/\/api.douban.com\/v2\/book\/2696119","alt_title":"","author_intro":"Joshua Bloch is chief Java architect at Google and a Jolt Award winner. He was previously a distinguished engineer at Sun Microsystems and a senior systems designer at Transarc. Bloch led the design and implementation of numerous Java platform features, including JDK 5.0 language enhancements and the award-winning Java Collections Framework. He coauthored Java™ Puzzlers (Addison-Wesley, 2005) and Java™ Concurrency in Practice (Addison-Wesley, 2006).","summary":"Written for the working Java developer, Joshua Bloch's Effective Java Programming Language Guide provides a truly useful set of over 50 best practices and tips for writing better Java code. With plenty of advice from an indisputable expert in the field, this title is sure to be an indispensable resource for anyone who wants to get more out of their code.\nAs a veteran developer at Sun, the author shares his considerable insight into the design choices made over the years in Sun's own Java libraries (which the author acknowledges haven't always been perfect). Based on his experience working with Sun's best minds, the author provides a compilation of 57 tips for better Java code organized by category. Many of these ideas will let you write more robust classes that better cooperate with built-in Java APIs. Many of the tips make use of software patterns and demonstrate an up-to-the-minute sense of what works best in today's design. Each tip is clearly introduced and explained with code snippets used to demonstrate each programming principle.\nEarly sections on creating and destroying objects show you ways to make better use of resources, including how to avoid duplicate objects. Next comes an absolutely indispensable guide to implementing \"required\" methods for custom classes. This material will help you write new classes that cooperate with old ones (with advice on implementing essential requirements like the equals() and hashCode() methods).\nThe author has a lot to say about class design, whether using inheritance or composition. Tips on designing methods show you how to create understandable, maintainable, and robust classes that can be easily reused by others on your team. Sections on mapping C code (like structures, unions, and enumerated types) onto Java will help C programmers bring their existing skills to Sun's new language. Later sections delve into some general programming tips, like using exceptions effectively. The book closes with advice on using threads and synchronization techniques, plus some worthwhile advice on object serialization.\nWhatever your level of Java knowledge, this title can make you a more effective programmer. Wisely written, yet never pompous or doctrinaire, the author has succeeded in packaging some really valuable nuggets of advice into a concise and very accessible guidebook that arguably deserves a place on most any developer's bookshelf. --Richard Dragan\nTopics covered:\nBest practices and tips for Java\nCreating and destroying objects (static factory methods, singletons, avoiding duplicate objects and finalizers)\nRequired methods for custom classes (overriding equals(), hashCode(), toString(), clone(), and compareTo() properly)\nHints for class and interface design (minimizing class and member accessibility, immutability, composition versus inheritance, interfaces versus abstract classes, preventing subclassing, static versus nonstatic classes)\nC constructs in Java (structures, unions, enumerated types, and function pointers in Java)\nTips for designing methods (parameter validation, defensive copies, method signatures, method overloading, zero-length arrays, hints for Javadoc comments)\nGeneral programming advice (local variable scope, using Java API libraries, avoiding float and double for exact comparisons, when to avoid strings, string concatenation, interfaces and reflection, avoid native methods, optimizing hints, naming conventions)\nProgramming with exceptions (checked versus run-time exceptions, standard exceptions, documenting exceptions, failure-capture information, failure atomicity)\nThreading and multitasking (synchronization and scheduling hints, thread safety, avoiding thread groups)\nSerialization (when to implement Serializable, the readObject(), and readResolve() methods)","price":"USD 54.99"},{"rating":{"max":10,"numRaters":128,"average":"8.4","min":0},"subtitle":"Java性能优化权威指南","author":["Charlie Hunt","Binu John"],"pubdate":"2014-3","tags":[{"count":367,"name":"Java","title":"Java"},{"count":208,"name":"性能优化","title":"性能优化"},{"count":131,"name":"JVM","title":"JVM"},{"count":119,"name":"性能","title":"性能"},{"count":67,"name":"优化","title":"优化"},{"count":63,"name":"java","title":"java"},{"count":49,"name":"计算机","title":"计算机"},{"count":48,"name":"编程","title":"编程"}],"origin_title":"Java Performance","image":"https://img1.doubanio.com\/mpic\/s27219217.jpg","binding":"平装","translator":["柳飞","陆明刚"],"catalog":"第1章　策略、方法和方法论　　1\n1.1 　性能问题的现状　　1\n1.2 　性能分析的两种方法：自顶向下和自底向上　　4\n1.2.1 　自顶向下　　4\n1.2.2 　自底向上　　5\n1.3 　选择正确的平台并评估系统性能　　5\n1.3.1 　选择正确的CPU架构　　6\n1.3.2 　评估系统性能　　7\n1.4 　参考资料　　7\n第2章　操作系统性能监控　　8\n2.1 　定义　　8\n2.2 　CPU使用率　　9\n2.2.1 　监控CPU使用率：Windows　　9\n2.2.2 　监控CPU使用率：Windows typeperf　　12\n2.2.3 　监控CPU使用率：Linux　　13\n2.2.4 　监控CPU使用率：Solaris　　14\n2.2.5 　命令行监控CPU使用率：Linux和Solaris　　16\n2.3 　CPU调度程序运行队列　　19\n2.3.1 　监控CPU调度程序运行队列：Windows　　19\n2.3.2 　监控CPU调度程序运行队列：Solaris　　21\n2.3.3 　监控CPU调度程序运行队列：Linux　　21\n2.4 　内存使用率　　22\n2.4.1 　监控内存利用率：Windows　　22\n2.4.2 　监控内存使用率：Solaris　　23\n2.4.3 　监控内存使用率：Linux　　24\n2.4.4 　监控锁竞争：Solaris　　25\n2.4.5 　监控锁竞争：Linux　　26\n2.4.6 　监控锁竞争：Windows　　27\n2.4.7 　隔离竞争锁　　27\n2.4.8 　监控抢占式上下文切换　　27\n2.4.9 　监控线程迁移　　28\n2.5 　网络I\/O使用率　　28\n2.5.1 　监控网络I\/O使用率：Solaris　　29\n2.5.2 　监控网络I\/O使用率：Linux　　30\n2.5.3 　监控网络I\/O使用率：Windows　　30\n2.5.4 　应用性能改进的考虑　　31\n2.6 　磁盘I\/O使用率　　31\n2.7 　其他命令行工具　　34\n2.8 　监控CPU使用率：SPARC T系列系统　　35\n2.9 　参考资料　　36\n第3章　JVM概览　　38\n3.1 　HotSpot VM的基本架构　　38\n3.2 　HotSpot VM运行时　　40\n3.2.1 　命令行选项　　40\n3.2.2 　VM生命周期　　41\n3.2.3 　VM类加载　　44\n3.2.4 　字节码验证　　46\n3.2.5 　类数据共享　　47\n3.2.6 　解释器　　48\n3.2.7 　异常处理　　49\n3.2.8 　同步　　50\n3.2.9 　线程管理　　51\n3.2.10 　C++堆管理　　53\n3.2.11 　Java本地接口　　54\n3.2.12 　VM致命错误处理　　55\n3.3 　HotSpot VM垃圾收集器　　56\n3.3.1 　分代垃圾收集　　56\n3.3.2 　新生代　　58\n3.3.3 　快速内存分配　　60\n3.3.4 　垃圾收集器　　60\n3.3.5 　Serial收集器　　61\n3.3.6 　Parallel收集器：吞吐量为先！　　62\n3.3.7　　Mostly-Concurrent收集器：低延迟为先！　　62\n3.3.8　　Garbage-First收集器：CMS替代者　　64\n3.3.9 　垃圾收集器比较　　64\n3.3.10 　应用程序对垃圾收集器的影响　　65\n3.3.11 　简单回顾收集器历史　　65\n3.4 　HotSpot VM JIT编译器　　65\n3.4.1 　类型继承关系分析　　67\n3.4.2 　编译策略　　67\n3.4.3 　逆优化　　68\n3.4.4 　Client JIT编译器概览　　69\n3.4.5 　Server JIT编译器概览　　69\n3.4.6 　静态单赋值——程序依赖图　　69\n3.4.7 　未来增强展望　　71\n3.5 　HotSpot VM自适应调优　　71\n3.5.1 　Java 1.4.2的默认值　　71\n3.5.2 　Java 5自动优化的默认值　　71\n3.5.3 　Java 6 Update 18更新后的默认优化值　　73\n3.5.4 　自适应Java堆调整　　74\n3.5.5 　超越自动优化　　75\n3.6 　参考资料　　75\n第4章　JVM性能监控　　77\n4.1 　定义　　77\n4.2 　垃圾收集　　78\n4.2.1 　重要的垃圾收集数据　　78\n4.2.2 　垃圾收集报告　　78\n4.2.3 　垃圾收集数据的离线分析　　86\n4.2.4 　图形化工具　　89\n4.3 　JIT编译器　　103\n4.4 　类加载　　104\n4.5 　Java应用监控　　106\n4.6 　参考资料　　109\n第5章　Java应用性能分析　　110\n5.1 　术语　　111\n5.1.1 　通用性能分析术语　　111\n5.1.2 　Oracle Solaris Studio Performance Analyzer术语　　112\n5.1.3 　NetBeans Profiler术语　　112\n5.2 　Oracle Solaris Studio Performance Analyzer　　112\n5.2.1 　支持平台　　113\n5.2.2 　下载\/安装Oracle Solaris Studio Performance Analyzer　　114\n5.2.3 　使用Oracle Solaris Studio Performance Analyzer 抓取性能数据　　114\n5.2.4 　查看性能数据　　118\n5.2.5 　数据表示　　125\n5.2.6 　过滤性能数据　　128\n5.2.7 　命令行工具er_print　　129\n5.3 　NetBeans Profiler　　135\n5.3.1 　支持平台　　136\n5.3.2 　下载安装NetBeans Profiler　　136\n5.3.3 　开始方法分析会话　　137\n5.3.4 　Controls子面板　　143\n5.3.5 　Status子面板　　143\n5.3.6 　Profiling Results子面板　　143\n5.3.7 　Saved Snapshots子面板　　144\n5.3.8 　View子面板　　144\n5.3.9 　Basic Telemetry子面板　　144\n5.3.10 　查看动态结果　　145\n5.3.11 　对结果进行快照　　145\n5.3.12 　启动内存分析会话　　146\n5.3.13 　查看实时结果　　148\n5.3.14 　对结果进行快照　　150\n5.3.15 　定位内存泄漏　　150\n5.3.16 　分析堆转储　　151\n5.4 　参考资料　　152\n第6章　Java应用性能分析技巧　　153\n6.1 　性能优化机会　　153\n6.2 　系统或内核态CPU使用　　154\n6.3 　锁竞争　　161\n6.4 　Volatile的使用　　171\n6.5 　调整数据结构的大小　　172\n6.5.1 　StringBuilder或StringBuffer大小的调整　　172\n6.5.2 　Java Collection类大小调整　　175\n6.6 　增加并行性　　179\n6.7 　过高的CPU使用率　　181\n6.8 　其他有用的分析提示　　182\n6.9 　参考资料　　184\n第7章　JVM性能调优入门　　185\n7.1 　方法　　185\n7.1.1 　假设条件　　187\n7.1.2 　测试基础设施需求　　188\n7.2 　应用程序的系统需求　　188\n7.2.1 　可用性　　188\n7.2.2 　可管理性　　188\n7.2.3 　吞吐量　　189\n7.2.4 　延迟及响应性　　189\n7.2.5 　内存占用　　189\n7.2.6 　启动时间　　189\n7.3 　对系统需求分级　　190\n7.4 　选择JVM部署模式　　190\n7.4.1 　单JVM部署模式　　190\n7.4.2 　多JVM部署模式　　190\n7.4.3 　通用建议　　191\n7.5 　选择JVM运行模式　　191\n7.5.1 　Client模式或Server模式　　191\n7.5.2 　32位\/64位 JVM　　192\n7.5.3 　垃圾收集器　　192\n7.6 　垃圾收集调优基础　　193\n7.6.1 　性能属性　　193\n7.6.2 　原则　　193\n7.6.3 　命令行选项及GC日志　　194\n7.7 　确定内存占用　　197\n7.7.1 　约束　　197\n7.7.2 　HotSpot VM堆的布局　　197\n7.7.3 　堆大小调优着眼点　　200\n7.7.4 　计算活跃数据大小　　201\n7.7.5 　初始堆空间大小配置　　202\n7.7.6 　其他考量因素　　203\n7.8 　调优延迟\/响应性　　204\n7.8.1 　输入　　205\n7.8.2 　优化新生代的大小　　205\n7.8.3 　优化老年代的大小　　207\n7.8.4 　为CMS调优延迟　　210\n7.8.5 　Survivor空间介绍　　212\n7.8.6 　解析晋升阈值　　214\n7.8.7 　监控晋升阈值　　215\n7.8.8 　调整Survivor空间的容量　　216\n7.8.9 　显式的垃圾收集　　222\n7.8.10 　并发永久代垃圾收集　　223\n7.8.11 　调优CMS停顿时间　　224\n7.8.12 　下一步　　225\n7.9 　应用程序吞吐量调优　　225\n7.9.1 　CMS吞吐量调优　　225\n7.9.2 　Throughput收集器调优　　226\n7.9.3 　Survivor空间调优　　228\n7.9.4 　调优并行垃圾收集线程　　231\n7.9.5 　在NUMA系统上部署　　231\n7.9.6 　下一步　　232\n7.10 　极端示例　　232\n7.11 　其他性能命令行选项　　232\n7.11.1 　实验性（最近最大）优化　　232\n7.11.2 　逃逸分析　　233\n7.11.3 　偏向锁　　233\n7.11.4 　大页面支持　　234\n7.12 　参考资料　　236\n第8章　Java应用的基准测试　　237\n8.1 　基准测试所面临的挑战　　237\n8.1.1 　基准测试的预热阶段　　238\n8.1.2 　垃圾收集　　240\n8.1.3 　使用Java Time接口　　240\n8.1.4 　剔除无效代码　　241\n8.1.5 　内联　　247\n8.1.6 　逆优化　　251\n8.1.7 　创建微基准测试的注意事项　　256\n8.2 　实验设计　　257\n8.3 　使用统计方法　　258\n8.3.1 　计算均值　　258\n8.3.2 　计算标准差　　258\n8.3.3 　计算置信区间　　259\n8.3.4 　使用假设测试　　260\n8.3.5 　使用统计方法的注意事项　　262\n8.4 　参考文献　　263\n8.5 　参考资料　　263\n第9章　多层应用的基准测试　　264\n9.1 　基准测试难题　　264\n9.2 　企业级应用基准测试的考量　　266\n9.2.1 　定义被测系统　　266\n9.2.2 　制定微基准测试　　266\n9.2.3 　定义用户交互模型　　267\n9.2.4 　定义性能指标　　270\n9.2.5 　扩展基准测试　　273\n9.2.6 　用利特尔法则验证　　274\n9.2.7 　思考时间　　275\n9.2.8 　扩展性分析　　278\n9.2.9 　运行基准测试　　278\n9.3 　应用服务器监控　　281\n9.3.1 　GlassFish监控　　281\n9.3.2 　监控子系统　　286\n9.3.3 　Solaris　　287\n9.3.4 　Linux　　288\n9.3.5 　Windows　　288\n9.3.6 　外部系统的性能　　289\n9.3.7 　磁盘I\/O　　292\n9.3.8 　监控和调优资源池　　293\n9.4 　企业级应用性能分析　　294\n9.5 　参考资料　　295\n第10章　Web应用的性能调优　　297\n10.1 　Web应用的基准测试　　298\n10.2 　Web容器的组件　　298\n10.2.1 　HTTP连接器　　299\n10.2.2 　Servlet引擎　　300\n10.3 　Web容器的监控和性能调优　　300\n10.3.1 　容器的开发和生产模式　　300\n10.3.2 　安全管理器　　301\n10.3.3 　JVM调优　　301\n10.3.4 　HTTP服务和Web容器　　303\n10.3.5 　HTTP监听器　　303\n10.4 　最佳实践　　315\n10.4.1 　Servlet和JSP最佳实践　　315\n10.4.2 　内容缓存　　324\n10.4.3 　会话持久化　　328\n10.4.4 　HTTP服务器文件缓存　　329\n10.5 　参考资料　　333\n第11章　Web Service的性能　　334\n11.1 　XML的性能　　334\n11.1.1 　XML处理的生命周期　　335\n11.1.2 　解析\/解编组　　335\n11.1.3 　访问　　338\n11.1.4 　修改　　338\n11.1.5 　序列化\/编组　　339\n11.2 　验证　　339\n11.3 　解析外部实体　　341\n11.4 　XML文档的局部处理　　343\n11.5 　选择合适的API　　346\n11.6 　JAX-WS参考实现栈　　349\n11.7 　Web Service基准测试　　350\n11.8 　影响Web Service性能的因素　　353\n11.8.1 　消息大小的影响　　353\n11.8.2 　不同Schema类型的性能特征　　355\n11.8.3 　终端服务器的实现　　358\n11.8.4 　处理程序的性能　　359\n11.9 　最佳性能实践　　361\n11.9.1 　二进制负载的处理　　361\n11.9.2 　处理XML文档　　365\n11.9.3 　使用MTOM发送XML文档　　365\n11.9.4 　使用Provider接口　　368\n11.9.5 　快速信息集　　370\n11.9.6 　HTTP压缩　　372\n11.9.7 　Web Service客户端的性能　　373\n11.10 　参考资料　　374\n第12章　Java持久化及Enterprise Java Bean的性能　　375\n12.1 　EJB编程模型　　376\n12.2 　Java持久化API及其参考实现　　376\n12.3 　监控及调优EJB容器　　379\n12.3.1 　线程池　　380\n12.3.2 　Bean池和缓存　　382\n12.3.3 　EclipseLink会话缓存　　385\n12.4 　事务隔离级　　386\n12.5 　Enterprise Java Bean的最佳实践　　387\n12.5.1 　简要说明使用的EJB基准测试　　387\n12.5.2 　EJB 2.1　　388\n12.5.3 　EJB 3.0　　400\n12.6 　Java持久化最佳实践　　403\n12.6.1 　JPA查询语言中的查询　　403\n12.6.2 　查询结果缓存　　405\n12.6.3 　FetchType　　406\n12.6.4 　连接池　　408\n12.6.5 　批量更新　　409\n12.6.6 　选择正确的数据库锁策略　　411\n12.6.7 　不带事务的读取　　411\n12.6.8 　继承　　411\n12.7 　参考资料　　412\n附录A 　重要的HotSpot VM选项　　413\n附录B 　性能分析技巧示例源代码　　429\nB.1 　锁竞争实现1　　429\nB.2 　锁竞争实现2　　439\nB.3 　锁竞争实现3　　449\nB.4 　锁竞争实现4　　459\nB.5 　锁竞争实现5　　469\nB.6 　调整容量变化1　　481\nB.7 　调整容量变化2　　492\nB.8 　增加并发性的单线程实现　　504\nB.9 　增加并发性的多线程实现　　514\n","pages":"540","images":{"small":"https://img1.doubanio.com\/spic\/s27219217.jpg","large":"https://img1.doubanio.com\/lpic\/s27219217.jpg","medium":"https://img1.doubanio.com\/mpic\/s27219217.jpg"},"alt":"https:\/\/book.douban.com\/subject\/25828043\/","id":"25828043","publisher":"人民邮电出版社","isbn10":"7115342970","isbn13":"9787115342973","title":"Java性能优化权威指南","url":"https:\/\/api.douban.com\/v2\/book\/25828043","alt_title":"Java Performance","author_intro":"Charlie Hunt现任Salesforce公司的性能工程架构师。曾任Oracle公司首席JVM性能工程师，负责HotSpot Java虚拟机和Java SE类库性能的改进。Charlie拥有美国伊利诺伊理工大学的计算机科学硕士学位、爱荷华州立大学的计算机科学学士学位。\nBinu John是世界上最大的社交网站创建平台Ning.com的高级性能工程师。他目前的职责是着力改善Ning平台的性能和扩展性，以支持每月数百万PV的访问量。Binu拥有美国爱荷华大学生物医学工程和计算机科学硕士学位。","summary":"Java性能优化圣经！Java之父重磅推荐！\n本书由曾任职于Oracle\/Sun的性能优化专家编写，系统而详细地讲解了性能优化的各个方面，帮助你学习Java虚拟机的基本原理、掌握一些监控Java程序性能的工具，从而快速找到程序中的性能瓶颈，并有效改善程序的运行性能。\nJava性能优化的任何问题，都可以从本书中找到答案！","price":"109.00 元"},{"rating":{"max":10,"numRaters":192,"average":"8.5","min":0},"subtitle":"Java语言描述","author":["韦斯 (Mark Allen Weiss)"],"pubdate":"2009-1-1","tags":[{"count":217,"name":"数据结构","title":"数据结构"},{"count":167,"name":"Java","title":"Java"},{"count":157,"name":"算法","title":"算法"},{"count":83,"name":"算法、数据结构","title":"算法、数据结构"},{"count":58,"name":"计算机","title":"计算机"},{"count":40,"name":"编程","title":"编程"},{"count":27,"name":"程序设计","title":"程序设计"},{"count":27,"name":"java","title":"java"}],"origin_title":"Data Structures and Algorithm Analysis in Java","image":"https://img3.doubanio.com\/mpic\/s28318872.jpg","binding":"平装","translator":[],"catalog":"译者序\n前言\n第1章 引论\n1.1 本书讨论的内容\n1.2 数学知识复习\n1.2.1 指数\n1.2.2 对数\n1.2.3 级数\n1.2.4 模运算\n1.2.5 证明的方法\n1.3 递归简论\n1.4 实现泛型特性构件pre-Java5\n1.4.1 使用Object表示泛型\n1.4.2 基本类型的包装\n1.4.3 使用接口类型表示泛型\n1.4.4 数组类型的兼容性\n1.5 利用Java5泛性实现泛型特性成分\n1.5.1 简单的泛型类和接口\n1.5.2 自动装箱\/拆箱\n1.5.3 带有限制的通配符\n1.5.4 泛型static方法\n1.5.5 类型限界\n1.5.6 类型擦除\n1.5.7 对于泛型的限制\n1.6 函数对象\n小结\n练习\n参考文献\n第2章 算法分析\n2.1 数学基础\n2.2 模型\n2.3 要分析的问题\n2.4 运行时间计算\n2.4.1 一个简单的例子\n2.4.2 一般法则\n2.4.3 最大子序列和问题的求解\n2.4.4 运行时间中的对数\n2.4.5 检验你的分析\n2.4.6 分析结果的准确性\n小结\n练习\n参考文献\n第3章 表、栈和队列\n3.1 抽象数据类型\n3.2 表ADT\n3.2.1 表的简单数组实现\n3.2.2 简单链表\n3.3 Java Collections API中的表\n3.3.1 Collection接口\n3.3.2 Iterator接口\n3.3.3 List接口、ArrayList类和LinkedList类\n3.3.4 例：remove方法对LinkedList类的使用\n3.3.5 关于ListIterator接口\n3.4 ArrayList类的实现\n3.4.1 基本类\n3.4.2 迭代器、Java嵌套类和内部类\n3.5 Linked List类的实现\n3.6 栈ADT\n3.6.1 栈模型\n3.6.2 栈的实现\n3.6.3 应用\n3.7 队列ADT\n3.7.1 队列模型\n3.7.2 队列的数组实现\n3.7.3 队列的应用\n小结\n练习\n第4章 树\n4.1 预备知识\n4.1.1 树的实现\n4.1.2 树的遍历及应用\n4.2 二叉树\n4.2.1 实现\n4.2.2 例子：表达式树\n4.3 查找树ADT——二叉查找树\n4.3.1 contains方法\n4.3.2 findMin方法和findMax方法\n4.3.3 insert方法\n4.3.4 remove方法\n4.3.5 平均情况分析\n4.4 AVL树\n4.4.1 单旋转\n4.4.2 双旋转\n4.5 伸展树\n4.5.1 一个简单的想法（不能直接使用）\n4.5.2 展开\n4.6 树的遍历\n4.7 B树\n4.8 标准库中的集合与映射\n4.8.1 关于Set接口\n4.8.2 关于Map接口\n4.8.3 TreeSet类和TreeMap类的实现\n4.8.4 使用多个映射的例\n小结\n练习\n参考文献\n第5章 散列\n5.1 一般想法\n5.2 散列函数\n5.3 分离链接法\n5.4 不用链表的散列表\n5.4.1 线性探测法\n5.4.2 平方探测法\n5.4.3 双散列\n5.5 再散列\n5.6 标准库中的散列表\n5.7 可扩散列\n小结\n练习\n参考文献\n第6章 优先队列（堆）\n6.1 模型\n6.2 一些简单的实现\n6.3 二叉堆\n6.3.1 结构性质\n6.3.2 堆序性质\n6.3.3 基本的堆操作\n6.3.4 其他的堆操作\n6.4 优先队列的应用\n6.4.1 选择问题\n6.4.2 事件模拟\n6.5 d-堆\n6.6 左式堆\n6.6.1 左式堆性质\n6.6.2 左式堆操作\n6.7 斜堆\n6.8 二项队列\n6.8.1 二项队列结构\n6.8.2 二项队列操作\n6.8.3 二项队列的实现\n6.9 标准库中的优先队列\n小结\n练习\n参考文献\n第7章 排序\n7.1 预备知识\n7.2 插入排序\n7.2.1 算法\n7.2.2 插入排序的分析\n7.3 一些简单排序算法的下界\n7.4 希尔排序\n7.5 堆排序\n7.6 归并排序\n7.7 快速排序\n7.7.1 选取枢纽元\n7.7.2 分割策略\n7.7.3 小数组\n7.7.4 实际的快速排序例程\n7.7.5 快速排序的分析\n7.7.6 选择问题的线性期望时间算法\n7.8 排序算法的一般下界\n7.9 桶式排序\n7.10 外部排序\n7.10.1 为什么需要一些新的算法\n7.10.2 外部排序模型\n7.10.3 简单算法\n7.10.4 多路合并\n7.10.5 多相合并\n7.10.6 替换选择\n小结\n练习题\n参考文献\n第8章 不相交集类\n8.1 等价关系\n8.2 动态等价性问题\n8.3 基本数据结构\n8.4 灵巧求并算法\n8.5 路径压缩\n8.6 路径压缩和按秩求并的最坏情形\n8.7 一个应用\n小结\n练习题\n参考文献\n第9章 图论算法\n9.1 若干定义\n9.2 拓扑排序\n9.3 最短路径算法\n9.3.1 无权最短路径\n9.3.2 Dijkstra算法\n9.3.3 具有负边值的图\n9.3.4 无圈图\n9.3.5 所有点对最短路径\n9.3.6 最短路径的例子\n9.4 网络流问题\n9.5 最小生成树\n9.5.1 Prim算法\n9.5.2 Kruskal算法\n9.6 深度优先搜索的应用\n9.6.1 无向图\n9.6.2 双连通性\n9.6.3 欧拉回路\n9.6.4 有向图\n9.6.5 查找强分支\n9.7 NP完全性介绍\n9.7.1 难与易\n9.7.2 NP类\n9.7.3 NP完全问题\n小结\n练习\n参考文献\n第10章 算法设计技巧\n10.1 贪婪算法\n10.1.1 一个简单的调度问题\n10.1.2 哈夫曼编码\n10.1.3 近似装箱问题\n10.2 分治算法\n10.2.1 分治算法的运行时间\n10.2.2 最近点问题\n10.2.3 选择问题\n10.2.4 一些算术问题的理论改进\n10.3 动态规划\n10.3.1 用一个表代替递归\n10.3.2 矩阵乘法的顺序安排\n10.3.3 最优二叉查找树\n10.3.4 所有点对最短路径\n10.4 随机化算法\n10.4.1 随机数发生器\n10.4.2 跳跃表\n10.4.3 素性测试\n10.5 回溯算法\n10.5.1 收费公路重建问题\n10.5.2 博弈\n小结\n练习\n参考文献\n第11章 摊还分析\n11.1 一个无关的智力问题\n11.2 二项队列\n11.3 斜堆\n11.4 斐波那契堆\n11.4.1 切除左式堆中的节点\n11.4.2 二项队列的懒惰合并\n11.4.3 斐波那契堆操作\n11.4.4 时间界的证明\n11.5 伸展树\n小结\n练习\n参考文献\n第12章 高级数据结构及其实现\n12.1 自顶向下伸展树\n12.2 红黑树\n12.2.1 自底向上的插入\n12.2.2 自顶向下红黑树\n12.2.3 自顶向下的删除\n12.3 确定性跳跃表\n12.4 AA树\n12.5 treap树\n12.6 k-d树\n12.7 配对堆\n小结\n练习\n参考文献\n索引","pages":"400","images":{"small":"https://img3.doubanio.com\/spic\/s28318872.jpg","large":"https://img3.doubanio.com\/lpic\/s28318872.jpg","medium":"https://img3.doubanio.com\/mpic\/s28318872.jpg"},"alt":"https:\/\/book.douban.com\/subject\/3351237\/","id":"3351237","publisher":"机械工业出版社","isbn10":"711123183X","isbn13":"9787111231837","title":"数据结构与算法分析","url":"https:\/\/api.douban.com\/v2\/book\/3351237","alt_title":"Data Structures and Algorithm Analysis in Java","author_intro":"MarkAllen Weiss拥有普林斯顿大学计算机科学博士学位，现在是佛罗里达国际大学计算机学院教授。他是著名的计算机教育专家，在数据结构与算法分析方面卓有建树，著有多部畅销书籍：《Data Structures and Problem Solving：LJsirlg、Java》、《Data Structures and Problem Solving：Using C++》、《数据结构与算法分析——C语言描述》等。他目前是AP(AdvancedPlacement)计算机学科委员会成员。","summary":"本书是国外数据结构与算法分析方面的经典教材，使用卓越的Java编程语言作为实现工具讨论了数据结构（组织大量数据的方法）和算法分析（对算法运行时间的估计）。 随着计算机速度的不断增加和功能的日益强大，人们对有效编程和算法分析的要求也不断增长。本书把算法分析与最有效率的Java程序的开发有机地结合起来，深入分析每种算法，内容全面、缜密严格，并细致讲解精心构造程序的方法。","series":{"id":"1163","title":"计算机科学丛书"},"price":"55.00元"},{"rating":{"max":10,"numRaters":151,"average":"7.6","min":0},"subtitle":"Java Network Programming","author":["（美）Elliotte Rusty Harold"],"pubdate":"2005-11-22","tags":[{"count":158,"name":"java","title":"java"},{"count":132,"name":"网络编程","title":"网络编程"},{"count":74,"name":"java网络编程","title":"java网络编程"},{"count":43,"name":"Java","title":"Java"},{"count":42,"name":"O'Reilly","title":"O'Reilly"},{"count":31,"name":"网络","title":"网络"},{"count":29,"name":"编程","title":"编程"},{"count":28,"name":"程序设计","title":"程序设计"}],"origin_title":"","image":"https://img3.doubanio.com\/mpic\/s1455603.jpg","binding":"","translator":["朱涛江,林剑"],"catalog":"","pages":"718","images":{"small":"https://img3.doubanio.com\/spic\/s1455603.jpg","large":"https://img3.doubanio.com\/lpic\/s1455603.jpg","medium":"https://img3.doubanio.com\/mpic\/s1455603.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1438754\/","id":"1438754","publisher":"中国电力出版社","isbn10":"7508338405","isbn13":"9787508338408","title":"Java网络编程(中文版 第三版)(O＇Reilly Java系列)","url":"https:\/\/api.douban.com\/v2\/book\/1438754","alt_title":"JAVA Network Programming,Third Edition","author_intro":"Elliotte Rusty Harold是牛奶咖啡网站的作者，这是一个重要的在线资源，提供了有关Java的新闻。他还是XOM API的开发者，也是《Java I\/O》、《XML in a Nutshell》及很多有关Java和XML主题图书的作者。","summary":"《Java网络编程》第三版会为你介绍Java网络API的最新特性。本书讨论了JDK 1.4和1.5（现在已命名为J2SE 5）中所做的所有修改和增补。本书内容全面，涵盖了从网络基础知识到远程方法调用（RMI）等各方面的内容，书中章节涉及到TCP和UDP socket、服务器socket、URL和URI、组播以及特殊用途的API（如JavaMail）等等。本书展示了如何使用JSSE编写安全的网络应用程序，解释了如何使用NIO API编写超高性能的服务器。它还涵盖了Java对网络代理、Web cookie和URL缓存的支持。\n《Java网络编程》不仅仅是对API的解释：它还展示了如何使用API。本书有很多示例，包含了几千行可以实际工作的代码（所有代码都可以在线获得），实现了功能完整的网络客户端和服务器。无论是希望编写特殊用途的Web服务器、安全的在线订单接收程序、简单的组播代理还是电子邮件客户端，都会找到可供学习和借用的代码。\n无论你是经验丰富的网络开发人员、Java程序员新手，还是只希望对Java网络编程稍有些了解的人，都会发现《Java编程（第三版）》将成为你的书库中一个重要的部分。一旦开始使用Java网络API，只要你能想到它就能够做得到。","price":"85.00元"},{"rating":{"max":10,"numRaters":2911,"average":"9.1","min":0},"subtitle":"","author":["[美] Bruce Eckel"],"pubdate":"2007-6","tags":[{"count":2790,"name":"Java","title":"Java"},{"count":1130,"name":"编程思想","title":"编程思想"},{"count":866,"name":"编程","title":"编程"},{"count":750,"name":"TinkingInJava","title":"TinkingInJava"},{"count":693,"name":"计算机","title":"计算机"},{"count":551,"name":"程序设计","title":"程序设计"},{"count":436,"name":"经典","title":"经典"},{"count":354,"name":"软件开发","title":"软件开发"}],"origin_title":"Thinking in Java","image":"https://img3.doubanio.com\/mpic\/s27243455.jpg","binding":"平装","translator":["陈昊鹏"],"catalog":"读者评论\n前言\n简介\n第1章 对象导论\n1.1 抽象过程\n1.2 每个对象都有一个接口\n1.3 每个对象都提供服务\n1.4 被隐藏的具体实现\n1.5 复用具体实现\n1.6 继承\n1.6.1 “是一个”（is-a）与“像是一个”（is-like-a）关系\n1.7 伴随多态的可互换对象\n1.8 单根继承结构\n1.9 容器\n1.9.1 参数化类型（范型）\n1.10 对象的创建和生命期\n1.11 异常处理：处理错误\n1.12 并发编程\n1.13 Java与Internet\n1.13.1 Web是什么\n1.13.2 客户端编程\n1.13.3 服务器端编程\n1.22 总结\n第2章 一切都是对象\n2.1 用引用操纵对象\n2.2 必须由你创建所有对象\n2.2.1 存储到什么地方\n2.2.2 特例：基本类型\n2.2.3 Java中的数组\n2.3 永远不需要销毁对象\n2.3.1 作用域\n2.3.2 对象的作用域\n2.4 创建新的数据类型：类\n2.4.1 域和方法\n2.4.2 基本成员默认值\n2.5 方法、参数和返回值\n2.5.1 参数列表\n2.6 构建一个Java程序\n2.6.1 名字可见性\n2.6.2 运用其他构件\n2.6.3 static 关键字\n2.7 你的第一个Java程序\n编译和运行\n2.8 注释和嵌入式文档\n2.8.1 注释文档\n2.8.2 语法\n2.8.3 嵌入式HTML\n2.8.4 一些标签示例\n2.8.5 文档示例\n2.9 编码风格\n2.10 总结\n2.11 练习\n第3章 操作符\n3.1 更简单的打印语句\n3.2 使用Java操作符\n3.3 优先级\n3.4 赋值\n3.4.1 方法调用中的别名问题\n3.5 算术操作符\n3.5.1 一元加、减操作符\n3.6 自动递增和递减\n3.7 关系操作符\n3.7.1 测试对象的等价性\n3.8 逻辑操作符\n3.8.1 短路\n3.9 直接常量\n3.9.1 指数记数法\n3.10 按位操作符\n3.11 移位操作符\n3.12 三元操作符 if-else\n3.13 字符串操作符 + 和 +=\n3.14 使用操作符时常犯的错误\n3.15 类型转换操作符\n3.15.1 截尾和舍入\n3.15.2提升\n3.16 Java没有“sizeof”\n3.17 操作符小结\n3.18 总结\n第4章 控制执行流程\n4.1 true和false\n4.2 if-else\n4.3 迭代\n4.3.1 do-while\n4.3.2 for\n4.3.3 逗号操作符\n4.4 Foreach语法\n4.5 return\n4.6 break和 continue\n4.7 臭名昭著的“goto”\n4.8 switch\n4.9 总结\n第5章 初始化与清理\n5.1 用构造器确保初始化\n5.2 方法重载\n5.2.1 区分重载方法\n5.2.2 涉及基本类型的重载\n5.2.3 以返回值区分重载方法\n5.3 缺省构造器\n5.4 this关键字\n5.4.1 在构造器中调用构造器\n5.4.2 static的含义\n5.5 清理：终结处理和垃圾回收\n5.5.1 finalize()的用途何在\n5.5.2 你必须实施清理\n5.5.3 终结条件\n5.5.4 垃圾回收器如何工作\n5.6 成员初始化\n5.6.1 指定初始化\n5.7 构造器初始化\n5.7.1 初始化顺序\n5.7.2. 静态数据的初始化\n5.7.3. 显式的静态初始化\n5.7.4. 非静态实例初始化\n5.8 数组初始化\n5.8.1 可变参数列表\n5.9 枚举类型\n5.10 总结\n第6章 访问权限控制\n第7章 复用类\n第8章 多态\n第9章 接口\n第10章 内部类\n第11章 持有对象\n第12章 通过异常处理错误\n第13章 字符串\n第14章 类型信息\n第15章 泛型\n第16章 数组\n第17章 容器深入研究\n第18章 Java I\/O系统\n第19章 枚举类型\n第20章 注解\n第21章 并发\n第22章 图形化用户界面\n附录A 补充材料\n可下载的补充材料\nThinking in C：Java的基础\nJava编程思想 研讨课\nHands-on Java研讨课CD\nThinking in Objects研讨课\nThinking in Enterprise Java\nThinking in Patterns(with Java)\nThinking in Patterns研讨课\n设计咨询与复审\n附录B 资源\n软件\n编辑器与IDE\n书籍\n分析与设计\nPython\n我的著作列表\n索引","pages":"880","images":{"small":"https://img3.doubanio.com\/spic\/s27243455.jpg","large":"https://img3.doubanio.com\/lpic\/s27243455.jpg","medium":"https://img3.doubanio.com\/mpic\/s27243455.jpg"},"alt":"https:\/\/book.douban.com\/subject\/2130190\/","id":"2130190","publisher":"机械工业出版社","isbn10":"7111213823","isbn13":"9787111213826","title":"Java编程思想 （第4版）","url":"https:\/\/api.douban.com\/v2\/book\/2130190","alt_title":"Thinking in Java","author_intro":"Bruce Eckel是MindView公司（www.MindView.net）的总裁，该公司向客户提供软件咨询和培训。他是C++标准委员会拥有表决权的成员之一，拥有应用物理学学士和计算机工程硕士学位。除本书外，他还是《C++编程思想》的作者，并与人合著了《C++编程思想 第2卷》（这两本书的英文影印版及中文版均已由机械工业出版社引进出版）及其他著作。他已经发表了150多篇论文，还经常参加世界各地的研讨会并进行演讲。","summary":"本书赢得了全球程序员的广泛赞誉，即使是最晦涩的概念，在Bruce Eckel的文字亲和力和小而直接的编程示例面前也会化解于无形。从Java的基础语法到最高级特性（深入的面向对象概念、多线程、自动项目构建、单元测试和调试等），本书都能逐步指导你轻松掌握。\n从本书获得的各项大奖以及来自世界各地的读者评论中，不难看出这是一本经典之作。本书的作者拥有多年教学经验，对C、C++以及Java语言都有独到、深入的见解，以通俗易懂及小而直接的示例解释了一个个晦涩抽象的概念。本书共22章，包括操作符、控制执行流程、访问权限控制、复用类、多态、接口、通过异常处理错误、字符串、泛型、数组、容器深入研究、Java I\/O系统、枚举类型、并发以及图形化用户界面等内容。这些丰富的内容，包含了Java语言基础语法以及高级特性，适合各个层次的Java程序员阅读，同时也是高等院校讲授面向对象程序设计语言以及Java语言的绝佳教材和参考书。\n第4版特点：\n适合初学者与专业人员的经典的面向对象叙述方式，为更新的Java SE5\/6增加了新的示例和章节。\n 测验框架显示程序输出。","series":{"id":"1163","title":"计算机科学丛书"},"price":"108.00元"},{"rating":{"max":10,"numRaters":188,"average":"7.7","min":0},"subtitle":"Java虚拟机多核编程实战","author":["[美]Venkat Subramaniam"],"pubdate":"2010-8","tags":[{"count":201,"name":"scala","title":"scala"},{"count":78,"name":"Java","title":"Java"},{"count":75,"name":"函数式编程","title":"函数式编程"},{"count":55,"name":"多核编程","title":"多核编程"},{"count":44,"name":"编程","title":"编程"},{"count":33,"name":"计算机","title":"计算机"},{"count":32,"name":"编程语言","title":"编程语言"},{"count":29,"name":"程序设计","title":"程序设计"}],"origin_title":"Programming Scala: Tackle Multi-Core Complexity on the Java Virtual Machine","image":"https://img3.doubanio.com\/mpic\/s4911906.jpg","binding":"","translator":["郑晔","李剑"],"catalog":"第1章 简介\t1\n1.1 为何选择Scala\t1\n1.2 何为Scala\t3\n1.3 函数式编程\t7\n1.4 本书的内容\t9\n1.5 本书面向的读者\t11\n1.6 致谢\t11\n第2章 起步\t13\n2.1 下载Scala\t13\n2.2 安装Scala\t13\n2.2.1 在Windows上安装Scala\t14\n2.2.2 在类UNIX系统上安装Scala\t14\n2.3 让Scala跑起来\t15\n2.4 命令行上的Scala\t16\n2.5 把Scala代码当作脚本运行\t17\n2.5.1 在类UNIX系统上作为脚本运行\t17\n2.5.2 在Windows上作为脚本运行\t18\n2.6 在IDE里面运行Scala\t18\n2.7 编译Scala\t19\n第3章 Scala步入正轨\t20\n3.1 把Scala当作简洁的Java\t20\n3.2 Java基本类型对应的Scala类\t23\n3.3 元组与多重赋值\t23\n3.4 字符串与多行原始字符串\t25\n3.5 自适应的默认做法\t26\n3.6 运算符重载\t27\n3.7 Scala带给Java程序员的惊奇\t29\n3.7.1 赋值的结果\t29\n3.7.2 Scala的==\t30\n3.7.3 分号是半可选的\t31\n3.7.4 默认的访问修饰符\t32\n3.7.5 默认的访问修饰符以及如何修改\t32\n3.7.6 Scala的Protected\t33\n3.7.7 细粒度访问控制\t34\n3.7.8 避免显式return\t35\n第4章 Scala的类\t37\n4.1 创建类\t37\n4.2 定义字段、方法和构造函数\t38\n4.3 类继承\t41\n4.4 单例对象\t42\n4.5 独立对象和伴生对象\t43\n4.6 Scala中的static\t44\n第5章 自适应类型\t46\n5.1 容器和类型推演\t47\n5.2 Any类型\t49\n5.3 关于Nothing的更多情况\t50\n5.4 Option类型\t50\n5.5 方法返回类型推演\t51\n5.6 传递变参\t52\n5.7 参数化类型的可变性\t53\n第6章 函数值和闭包\t57\n6.1 从普通函数迈向高阶函数\t57\n6.2 函数值\t58\n6.3 具有多参数的函数值\t59\n6.4 Curry化\t61\n6.5 重用函数值\t62\n6.6 参数的位置记法\t64\n6.7 Execute Around Method模式\t65\n6.8 偏应用函数\t67\n6.9 闭包\t68\n第7章 Trait和类型转换\t70\n7.1 Trait\t70\n7.2 选择性混入\t72\n7.3 以trait进行装饰\t74\n7.4 Trait方法的延迟绑定\t75\n7.5 隐式类型转换\t77\n第8章 使用容器\t81\n8.1 常见的Scala容器\t81\n8.2 使用Set\t82\n8.3 使用Map\t83\n8.4 使用List\t85\n8.5 for表达式\t90\n第9章 模式匹配和正则表达式\t93\n9.1 匹配字面量和常量\t93\n9.2 匹配通配符\t94\n9.3 匹配元组和列表\t94\n9.4 类型和卫述句的匹配\t96\n9.5 case表达式里的模式变量和常量\t96\n9.6 对XML片段进行模式匹配\t98\n9.7 使用case类进行模式匹配\t98\n9.8 使用提取器进行匹配\t100\n9.9 正则表达式\t103\n9.10 把正则表达式当做提取器\t104\n第10章 并发编程\t106\n10.1 促进不变性\t106\n10.2 使用Actor的并发\t107\n10.3 消息传递\t110\n10.4 Actor类\t113\n10.5 actor方法\t115\n10.6 receive和receiveWithin方法\t117\n10.7 react和reactWithin方法\t120\n10.8 loop和loopWhile\t124\n10.9 控制线程执行\t125\n10.10 在各种接收方法中选择\t127\n第11章 与Java互操作\t128\n11.1 在Scala里使用Scala类\t128\n11.2 在Scala里使用Java类\t130\n11.3 在Java里使用Scala类\t132\n11.3.1 有普通函数和高阶函数的Scala类\t132\n11.3.2 同trait一起工作\t134\n11.3.3 单例对象和伴生对象\t134\n11.4 继承类\t136\n第12章 用Scala做单元测试\t138\n12.1 使用JUnit\t138\n12.2 使用ScalaTest\t139\n12.3 以Canary测试开始\t140\n12.4 使用Runner\t140\n12.5 Asserts\t142\n12.6 异常测试\t144\n12.7 在测试间共享代码\t146\n12.7.1 用BeforeAndAfter共享代码\t146\n12.7.2 用闭包共享代码\t147\n12.8 FunSuite的函数式风格\t148\n12.9 用JUnit运行ScalaTest\t149\n第13章 异常处理\t152\n13.1 异常处理\t152\n13.2 注意catch顺序\t154\n第14章 使用Scala\t156\n14.1 净资产应用实例\t156\n14.2 获取用户输入\t156\n14.3 读写文件\t157\n14.4 XML，作为一等公民\t159\n14.5 读写XML\t161\n14.6 从Web获取股票价格\t164\n14.7 让净资产应用并发\t167\n14.8 为净资产应用增加GUI\t168\n附录A Web资源\t178","ebook_url":"https:\/\/read.douban.com\/ebook\/2112127\/","pages":"180","images":{"small":"https://img3.doubanio.com\/spic\/s4911906.jpg","large":"https://img3.doubanio.com\/lpic\/s4911906.jpg","medium":"https://img3.doubanio.com\/mpic\/s4911906.jpg"},"alt":"https:\/\/book.douban.com\/subject\/4909629\/","id":"4909629","publisher":"人民邮电出版社","isbn10":"7115232954","isbn13":"9787115232953","title":"Scala程序设计","url":"https:\/\/api.douban.com\/v2\/book\/4909629","alt_title":"Programming Scala: Tackle Multi-Core Complexity on the Java Virtual Machine","author_intro":"Venkat Subramaniam，Agile Developer创办人，培训并指导了美国、加拿大、印度和欧洲多国的上千名软件开发人员，并多次应邀在各种大会上发表演讲。他是《高效程序员的45个习惯：敏捷开发修炼之道》（2007年Jolt大奖作品）的第一作者，还著有.NET Gotchas（O’Reilly）、Programming Groovy（Pragmatic）等书。","summary":"Scala是一种针对 JVM 的通用的编程语言，用来以简明、优雅、类型安全的方式表示常见的编程模式。它无缝集成了面向对象语言和函数式语言的特性，可以大大提高JAVA程序员的编程效率。Twitter、SAP等知名企业已经开始在一些应用里使用Scala，很多新的程序员也开始学习它。\n本书循序渐进地介绍了Scala的函数式编程基础，虽然篇幅短小，却切中要害。读者可以学会使用Scala静态语言的强大功能创建简洁、可扩展、高度可并行的代码。对于多核时代JVM上的并发编程，Scala是绝好的工具，而本书是你必不可少的向导。","ebook_price":"18.00","series":{"id":"660","title":"图灵程序设计丛书"},"price":"39.00"},{"rating":{"max":10,"numRaters":123,"average":"8.1","min":0},"subtitle":"让你的Java程序更快、更稳定","author":["葛一鸣"],"pubdate":"2012-9-1","tags":[{"count":186,"name":"Java","title":"Java"},{"count":102,"name":"性能优化","title":"性能优化"},{"count":68,"name":"性能","title":"性能"},{"count":42,"name":"java","title":"java"},{"count":29,"name":"编程","title":"编程"},{"count":24,"name":"计算机","title":"计算机"},{"count":22,"name":"程序设计","title":"程序设计"},{"count":20,"name":"优化","title":"优化"}],"origin_title":"","image":"https://img1.doubanio.com\/mpic\/s25101909.jpg","binding":"平装","translator":[],"catalog":"第1章 Java性能调优概述\n1.1 性能概述\n1.1.1 看懂程序的性能\n1.1.2 性能的参考指标\n1.1.3 木桶原理与性能瓶颈\n1.1.4 Amdahl定律\n1.2 性能调优的层次\n1.2.1 设计调优\n1.2.2 代码调优\n1.2.3 JVM调优\n1.2.4 数据库调优\n1.2.5 操作系统调优\n1.3 基本调优策略和手段\n1.3.1 优化的一般步骤\n1.3.2 系统优化注意事项\n1.4 小结\n第2章 设计优化\n2.1 善用设计模式\n2.1.1 单例模式\n2.1.2 代理模式\n2.1.3 享元模式\n2.1.4 装饰者模式\n2.1.5 观察者模式\n2.1.6 Value Object模式\n2.1.7 业务代理模式\n2.2 常用优化组件和方法\n2.2.1 缓冲（Buffer）\n2.2.2 缓存（Cache）\n2.2.3 对象复用——“池”\n2.2.4 并行替代串行\n2.2.5 负载均衡\n2.2.6 时间换空间\n2.2.7 空间换时间\n2.3 小结\n第3章 Java程序优化\n3.1 字符串优化处理\n3.1.1 String对象及其特点\n3.1.2 subString()方法的内存泄漏\n3.1.3 字符串分割和查找\n3.1.4 StringBuffer和StringBuilder\n3.2 核心数据结构\n3.2.1 List接口\n3.2.2 Map接口\n3.2.3 Set接口\n3.2.4 优化集合访问代码\n3.2.5 RandomAccess接口\n3.3 使用NIO提升性能\n3.3.1 NIO的Buffer类族和Channel\n3.3.2 Buffer的基本原理\n3.3.3 Buffer的相关操作\n3.3.4 MappedByteBuffer性能评估\n3.3.5 直接内存访问\n3.4 引用类型\n3.4.1 强引用\n3.4.2 软引用\n3.4.3 弱引用\n3.4.4 虚引用\n3.4.5 WeakHashMap类及其实现\n3.5 有助于改善性能的技巧\n3.5.1 慎用异常\n3.5.2 使用局部变量\n3.5.3 位运算代替乘除法\n3.5.4 替换switch\n3.5.5 一维数组代替二维数组\n3.5.6 提取表达式\n3.5.7 展开循环\n3.5.8 布尔运算代替位运算\n3.5.9 使用arrayCopy ()\n3.5.10 使用Buffer进行I\/O操作\n3.5.11 使用clone()代替new\n3.5.12 静态方法替代实例方法\n3.6 小结\n第4章 并行程序开发及优化\n4.1 并行程序设计模式\n4.1.1 Future模式\n4.1.2 Master-Worker模式\n4.1.3 Guarded Suspension模式\n4.1.4 不变模式\n4.1.5 生产者-消费者模式\n4.2 JDK多任务执行框架\n4.2.1 无限制线程的缺陷\n4.2.2 简单的线程池实现\n4.2.3 Executor框架\n4.2.4 自定义线程池\n4.2.5 优化线程池大小\n4.2.6 扩展ThreadPoolExecutor\n4.3 JDK并发数据结构\n4.3.1 并发List\n4.3.2 并发Set\n4.3.3 并发Map\n4.3.4 并发Queue\n4.3.5 并发Deque\n4.4 并发控制方法\n4.4.1 Java内存模型与volatile\n4.4.2 同步关键字synchronized\n4.4.3 ReentrantLock重入锁\n4.4.4 ReadWriteLock读写锁\n4.4.5 Condition对象\n4.4.6 Semaphore信号量\n4.4.7 ThreadLocal线程局部变量\n4.5 “锁”的性能和优化\n4.5.1 线程的开销\n4.5.2 避免死锁\n4.5.3 减小锁持有时间\n4.5.4 减小锁粒度\n4.5.5 读写分离锁来替换独占锁\n4.5.6 锁分离\n4.5.7 重入锁ReentrantLock和内部锁synchronized\n4.5.8 锁粗化(Lock Coarsening)\n4.5.9 自旋锁（Spinning Lock）\n4.5.10 锁消除（Lock Elimination）\n4.5.11 锁偏向(Biased Lock)\n4.6 无锁的并行计算\n4.6.1 非阻塞的同步\/无锁\n4.6.2 原子操作\n4.6.3 Amino框架介绍\n4.6.4 Amino集合\n4.6.5 Amino树\n4.6.6 Amino图\n4.6.7 Amino简单调度模式\n4.7 协程\n4.7.1 协程的概念\n4.7.2 Kilim框架简介\n4.7.3 Task及其状态\n4.7.4 Fiber及其状态\n4.7.5 Kilim开发环境配置\n4.7.6 Kilim之Hello World\n4.7.7 多任务通信\n4.7.8 Kilim实例及性能评估\n4.8 小结\n第5章 JVM调优\n5.1 Java虚拟机内存模型\n5.1.1 程序计数器\n5.1.2 Java虚拟机栈\n5.1.3 本地方法栈\n5.1.4 Java堆\n5.1.5 方法区\n5.2 JVM内存分配参数\n5.2.1 设置最大堆内存\n5.2.2 设置最小堆内存\n5.2.3 设置新生代\n5.2.4 设置持久代\n5.2.5 设置线程桟\n5.2.6 堆的比例分配\n5.2.7 堆分配参数总结\n5.3 垃圾收集基础\n5.3.1 垃圾收集的作用\n5.3.2 垃圾回收算法与思想\n5.3.3 垃圾收集器的类型\n5.3.4 评价GC策略的指标\n5.3.5 新生代串行收集器\n5.3.6 老年代串行收集器\n5.3.7 并行收集器\n5.3.8 新生代并行回收（Parallel Scavenge）收集器\n5.3.9 老年代并行回收收集器\n5.3.10 CMS收集器\n5.3.11 G1收集器（Garbage First）\n5.3.12 Stop the World案例\n5.3.13 收集器对系统性能的影响\n5.3.14 GC相关参数总结\n5.4 常用调优案例和方法\n5.4.1 将新对象预留在新生代\n5.4.2 大对象进入老年代\n5.4.3 设置对象进入老年代的年龄\n5.4.4 稳定与震荡的堆大小\n5.4.5 吞吐量优先案例\n5.4.6 使用大页案例\n5.4.7 降低停顿案例\n5.5 实用JVM参数\n5.5.1 JIT编译参数\n5.5.2 堆快照（堆Dump）\n5.5.3 错误处理\n5.5.4 取得GC信息\n5.5.5 类和对象跟踪\n5.5.6 控制GC\n5.5.7 选择类校验器\n5.5.8 Solaris下线程控制\n5.5.9 使用大页\n5.5.10 压缩指针\n5.6 实战JVM调优\n5.6.1 Tomcat简介与启动加速\n5.6.2 Web应用程序介绍\n5.6.3 JMeter介绍与使用\n5.6.4 调优前Web应用运行状况\n5.6.5 调优过程\n5.7 总结\n第6章 Java性能调优工具\n6.1 Linux命令行工具\n6.1.1 top命令\n6.1.2 sar命令\n6.1.3 vmstat命令\n6.1.4 iostat命令\n6.1.5 pidstat工具\n6.2 Windows工具\n6.2.1 任务管理器\n6.2.2 perfmon性能监控工具\n6.2.3 Process Explorer\n6.2.4 pslist命令行\n6.3 JDK命令行工具\n6.3.1 jps命令\n6.3.2 jstat命令\n6.3.3 jinfo命令\n6.3.4 jmap命令\n6.3.5 jhat命令\n6.3.6 jstack命令\n6.3.7 jstatd命令\n6.3.8 hprof工具\n6.4 JConsole工具\n6.4.1 JConsole连接Java程序\n6.4.2 Java程序概况\n6.4.3 内存监控\n6.4.4 线程监控\n6.4.5 类加载情况\n6.4.6 虚拟机信息\n6.4.7 MBean管理\n6.4.8 使用插件\n6.5 Visual VM多合一工具\n6.5.1 Visual VM连接应用程序\n6.5.2 监控应用程序概况\n6.5.3 Thread Dump和分析\n6.5.4 性能分析\n6.5.5 快照\n6.5.6 内存快照分析\n6.5.7 MBean管理\n6.5.8 TDA使用\n6.5.9 BTrace介绍\n6.6 Visual VM对OQL的支持\n6.6.1 Visual VM的OQL基本语法\n6.6.2 内置heap对象\n6.6.3 对象函数\n6.6.4 集合\/统计函数\n6.6.5 程序化OQL\n6.7 MAT内存分析工具\n6.7.1 初识MAT\n6.7.2 浅堆和深堆\n6.7.3 支配树（Dominator Tree）\n6.7.4 垃圾回收根\n6.7.5 内存泄露检测\n6.7.6 最大对象报告\n6.7.7 查找支配者\n6.7.8 线程分析\n6.7.9 集合使用情况分析\n6.7.10 扩展MAT\n6.8 MAT对OQL的支持\n6.8.1 Select子句\n6.8.2 From子句\n6.8.3 Where子句\n6.8.4 内置对象与方法\n6.9 JProfile简介\n6.9.1 JProfile使用配置\n6.9.2 内存视图\n6.9.3 堆快照\n6.9.4 CPU视图\n6.9.5 线程视图\n6.9.6 JVM统计信息\n6.9.7 触发器\n6.10 小结","pages":"416","images":{"small":"https://img1.doubanio.com\/spic\/s25101909.jpg","large":"https://img1.doubanio.com\/lpic\/s25101909.jpg","medium":"https://img1.doubanio.com\/mpic\/s25101909.jpg"},"alt":"https:\/\/book.douban.com\/subject\/19969386\/","id":"19969386","publisher":"清华大学出版社","isbn10":"7302296251","isbn13":"9787302296256","title":"Java程序性能优化","url":"https:\/\/api.douban.com\/v2\/book\/19969386","alt_title":"","author_intro":"葛一鸣，毕业于浙江工业大学，获得了计算机软件与理论专业硕士学位。取得了国家认证系统分析师职称、OCP（Oracle数据库认证专家）。现就职于UT斯达康通讯有限公司，从事Java软件开发。有多年的软件开发经验，参与开发过多个软件项目。熟悉Java、PHP、MySQL、Oracle等开发语言和数据库，对Java软件开发、性能优化、分布式软件有着浓厚的兴趣和深入的研究。在校期间曾经发表过多篇技术论文。","summary":"Java是目前应用最为广泛的软件开发平台，学习针对Java程序的优化方法有重要的现实意义。《Java程序性能优化：让你的Java程序更快、更稳定》以Java性能调优为主线，系统地阐述了与Java性能优化相关的知识与技巧。\n《Java程序性能优化：让你的Java程序更快、更稳定》共6章，先后从软件设计、软件编码、JVM调优以及程序故障排斥等方面介绍针对Java程序的优化方法。第1章介绍性能的基本概念、定律、系统调优的过程和注意事项。第2章从设计层面介绍与性能相关的设计模式、组件。第3章从代码层面介绍如何编写高性能的Java程序。第4章介绍了并行开发和如何通过多线程提高系统性能。第5章立足于JVM虚拟机层面，介绍如何通过设置合理的JVM参数提升Java程序的性能。第6章为工具篇，介绍了获取和监控程序或系统性能指标的各种工具，包括相关的故障排查工具。\n本书适合所有Java程序员、软件设计师、架构师以及软件开发爱好者，对于有一定经验的Java工程师，本书更能帮助他突破技术瓶颈，深入Java内核开发！","price":"59.00元"},{"rating":{"max":10,"numRaters":86,"average":"8.5","min":0},"subtitle":"Java世界的Lisp实践","author":["Chas Emerick","Brian Carper","Christophe Grand"],"pubdate":"2013-3-26","tags":[{"count":189,"name":"Clojure","title":"Clojure"},{"count":102,"name":"函数式","title":"函数式"},{"count":65,"name":"lisp","title":"lisp"},{"count":54,"name":"编程","title":"编程"},{"count":30,"name":"Java","title":"Java"},{"count":20,"name":"programming","title":"programming"},{"count":13,"name":"程度设计","title":"程度设计"},{"count":11,"name":"软件开发","title":"软件开发"}],"origin_title":"Clojure Programming","image":"https://img3.doubanio.com\/mpic\/s25803832.jpg","binding":"平装","translator":["徐明明","杨寿勋"],"catalog":"第1章 进入Clojure仙境\t1\n为什么要选择Clojure?\t1\n获取Clojure\t3\nClojure REPL\t3\n不！括号真的不会让你瞎了眼\t6\n表达式、操作符、语法以及优先级\t7\n同像性\t10\nClojure Reader\t12\n命名空间\t21\n符号解析\t23\n特殊形式\t24\n小结\t46\n这只是开始\t48\n第1部分 \t49\n第2章 函数式编程\t51\n所谓函数式编程，到底意味着什么？\t52\n谈谈值的重要性\t52\n作为头等公民的函数以及高阶函数\t59\n函数（功能）的组合\t68\n纯函数\t76\n现实生活中的函数式编程\t80\n第3章 集合类与数据结构\t83\n抽象优于实现\t84\n访问集合元素的简洁方式\t111\n数据结构的类型\t115\n不可变性和持久性\t123\n元数据\t136\n用Clojure的集合来小试牛刀\t137\n总结\t159\n第4章 多线程和并发\t161\n计算在时间和空间内的转换\t162\n简单的并行化\t168\n状态和标识\t170\nClojure的引用类型\t172\n并发操作的分类\t174\n原子类型（Atom）\t176\n通知和约束\t179\nref\t182\nvar\t200\nAgent\t211\n使用Java的并发原语\t227\n总结\t228\n第2部分 \t229\n第5 章 宏\t231\n宏到底是什么？\t231\n编写你的第一个宏\t237\n调试宏\t239\n语法\t242\n什么时候使用宏\t245\n宏卫生\t247\n宏的常见用法和模式\t253\n隐藏参数：&env 和 &form\t255\n深入 -> 和 ->>\t263\n总结\t266\n第6章 数据类型和协议\t267\n协议（Protocol）\t268\n扩展已有的类型\t270\n定义你自己的类型\t274\n实现协议\t284\n协议自省\t293\n协议函数分派的边界场景\t295\n自己实现一个set\t296\n总结\t304\n第7章 多重方法\t305\n多重方法基础\t305\n通往层级之路\t308\n层级\t310\n真正实现多重！\t315\n还有几件事\t317\n最后的思考\t321\n第3 部分 \t323\n第8章 Clojure项目的组织与构建\t325\n项目布局\t325\n构建\t339\n最后的思考\t355\n第9章 Java及JVM互操作\t357\nJVM是Clojure的基础\t358\nJava类、方法和字段的使用\t358\n便利的互操作工具\t361\n异常与错误处理\t363\n为了效率进行类型提示\t367\n定义类、实现接口\t372\n在Java里使用Clojure\t386\n乐于合作的伙伴\t393\n第10章 面向REPL的编程\t395\n交互式开发\t395\n工具集\t400\n在REPL里调试、监测和打补丁\t412\n重定义结构的限制\t416\n小结\t418\n第4部分 \t419\n第11章 数字与数学\t421\nClojure的数字\t421\nClojure数学\t427\n相等与等值\t432\n优化数值效率\t436\n用Clojure可视化芒德布罗集\t448\n第12章 设计模式\t457\n依赖注入\t459\n策略模式\t462\n责任链\t463\n面向方面的编程\t466\n最后的思考\t470\n第13章 测试\t471\n不可变值与纯函数\t471\nclojure.test\t473\nHTML DSL的成长\t482\n依赖断言\t486\n第14章 使用关系数据库\t491\nclojure.java.jdbc\t491\nKorma\t498\nHibernate\t503\n最后的思考\t510\n第15章 使用非关系型数据库\t511\n安装CouchDB和Clutch\t512\n基本的CRUD操作\t512\n视图\t513\n_changes: 把CouchDB滥用做消息队列\t519\n可随意点选的消息队列\t521\n最后的思考\t524\n第16章 Clojure与Web\t525\nClojure栈\t525\n基石：Ring\t526\n用Compojure路由请求\t533\n使用模板\t543\n最后的思考\t552\n第17章 布署Clojure Web应用程序\t553\nJava与Clojure Web架构\t553\n在本地运行Web应用\t561\nWeb应用程序布署\t562\n超越简单Web应用程序布署\t565\n第5部分 \t567\n第18章 明智地选择Clojure类型定义形式\t569\n第19章 在工作场所引进Clojure\t573\n只是事实…\t573\n强调生产效率\t574\n强调社群\t576\n审慎\t577\n第20章 下一步？\t579\n(dissoc Clojure ‘JVM)\t579\n4Clojure\t580\nOvertone\t581\ncore.logic\t581\nPallet\t582\nAvout\t582\nHeroku上的Clojure\t583\n关于作者\t585","pages":"618","images":{"small":"https://img3.doubanio.com\/spic\/s25803832.jpg","large":"https://img3.doubanio.com\/lpic\/s25803832.jpg","medium":"https://img3.doubanio.com\/mpic\/s25803832.jpg"},"alt":"https:\/\/book.douban.com\/subject\/21661495\/","id":"21661495","publisher":"电子工业出版社","isbn10":"7121197189","isbn13":"9787121197185","title":"Clojure编程","url":"https:\/\/api.douban.com\/v2\/book\/21661495","alt_title":"Clojure Programming","author_intro":"作者介绍：\nChas Emerick是软件公司Snowtide informatics的创始人。自2008年以来，致力于Clojure语言本身以及一些开源项目的开发；长期在cemerick.com撰写Clojure、软件开发实践、创业精神，及其他主题的文章。\nBrian Carpe r是一位心理学研究领域的专业程序员，用Clojure从事数据分析与web开发。他开发过一个把Clojure代码转化为CSS代码的编译器以及一个操作关系型数据库的类库，经常在briancarper.net上发表Clojure文章。\nChristophe Grand是一个独立顾问，现居法国里昂。他主要从事Clojure培训与编码，参与了Clojure语言的开发，撰写过Enlive和 Moustache类库，也是Counterclockwise——Clojure IDE for Eclipse的贡献者，经常在clj-me.cgrand.net上发表有关Clojure的文章。\n译者介绍：\n徐明明，阿里巴巴资深软件开发工程师，热衷于研究开源技术及语言；目前网络浏览量最大的Clojure入门教程（ http:\/\/xumingming.sinaapp.com\/302\/clojure-functional-programming-for-the-jvm-clojure-tutorial\/）即译自其手；参与Twitter开源实时计算框架Storm的开发，是该项目的核心贡献者(该项目的主要语言就是Clojure), 同时也翻译了该项目的很多文档，推进了该项目在中国的应用。","summary":"Clojure是一种实用的通用语言，它是传奇语言LISP的方言，可与Ruby、Python等动态语言相媲美，更以无缝Java库、服务，以及拥有JVM系统得天独厚的资源优势而胜出。本书既可以用来熟悉Clojure基础知识与常见例子，也可了解其相关的实践领域与话题，更可以看到这一JVM平台上的LISP如何帮助消除不必要的复杂性，为大家在编程实践中解决最具挑战性的问题开辟新的选择——更具灵活性，更适于Web编程和操作数据库，可以应付更为苛刻的应用程序安全要求，更有效的并发性和并行处理、数据分析能力，以及在未来云环境下的更大的发展潜力。","price":"99.00元"},{"rating":{"max":10,"numRaters":1288,"average":"9.0","min":0},"subtitle":"","author":["Joshua Bloch"],"pubdate":"2009-1-1","tags":[{"count":1082,"name":"java","title":"java"},{"count":670,"name":"Java","title":"Java"},{"count":549,"name":"编程","title":"编程"},{"count":344,"name":"effective","title":"effective"},{"count":287,"name":"计算机","title":"计算机"},{"count":277,"name":"程序设计","title":"程序设计"},{"count":232,"name":"经典","title":"经典"},{"count":185,"name":"软件开发","title":"软件开发"}],"origin_title":"Effective Java Second Edition","image":"https://img3.doubanio.com\/mpic\/s3479802.jpg","binding":"平装","translator":["俞黎敏"],"catalog":"译者序\n序\n前言\n致谢\n第1章 引言\n第2章 创建和销毁对象\n第1条：考虑用静态工厂方法代替构造器\n第2条：遇到多个构造器参数时要考虑用构建器\n第3条：用私有构造器或者枚举类型强化Singleton属性\n第4条：通过私有构造器强化不可实例化的能力\n第5条：避免创建不必要的对象\n第6条：消除过期的对象引用\n第7条：避免使用终结方法\n第3章 对于所有对象都通用的方法\n第8条：覆盖equals时请遵守通用约定\n第9条：覆盖equals时总要覆盖hashCode\n第10条：始终要覆盖toString\n第11条：谨慎地覆盖clone\n第12条：考虑实现Comparable接口\n第4章 类和接口\n第13条：使类和成员的可访问性最小化\n第14条：在公有类中使用访问方法而非公有域\n第15条：使可变性最小化\n第16条：复合优先于继承\n第17条：要么为继承而设计，并提供文档说明，要么就禁止继承\n第18条：接口优于抽象类\n第19条：接口只用于定义类型\n第20条：类层次优于标签类\n第21条：用函数对象表示策略\n第22条：优先考虑静态成员类\n第5章 泛型\n第23条：请不要在新代码中使用原生态类型\n第24条：消除非受检警告\n第25条：列表优先于数组\n第26条：优先考虑泛型\n第27条：优先考虑泛型方法\n第28条：利用有限制通配符来提升API的灵活性\n第29条：优先考虑类型安全的异构容器\n第6章 枚举和注解\n第30条：用enum代替int常量\n第31条：用实例域代替序数\n第32条：用EnumSet代替位域\n第33条：用EnumMap代替序数索引\n第34条：用接口模拟可伸缩的枚举\n第35条：注解优先于命名模式\n第36条：坚持使用Override注解\n第37条：用标记接口定义类型\n第7章 方法\n第38条：检查参数的有效性\n第39条：必要时进行保护性拷贝\n第40条：谨慎设计方法签名\n第41条：慎用重载\n第42条：慎用可变参数\n第43条：返回零长度的数组或者集合，而不是：null\n第44条：为所有导出的API元素编写文档注释\n第8章 通用程序设计\n第45条：将局部变量的作用域最小化\n第46条：for-each循环优先于传统的for循环\n第47条：了解和使用类库\n第48条：如果需要精确的答案，请避免使用float和double\n第49条：基本类型优先于装箱基本类型\n第50条：如果其他类型更适合，则尽量避免使用字符串\n第51条：当心字符串连接的性能\n第52条：通过接口引用对象\n第53条：接口优先于反射机制\n第54条：谨慎地使用本地方法\n第55条：谨慎地进行优化\n第56条：遵守普遍接受的命名惯例\n第9章 异常\n第57条：只针对异常的情况才使用异常\n第58条：对可恢复的情况使用受检异常，对编程错误使用运行时异常\n第59条：避免不必要地使用受检的异常\n第60条：优先使用标准的异常\n第61条：抛出与抽象相对应的异常\n第62条：每个方法抛出的异常都要有文档\n第63条：在细节消息中包含能捕获失败的信息\n第64条：努力使失败保持原子性\n第65条：不要忽略异常\n第10章 并发\n第66条：同步访问共享的可变数据\n第67条：避免过度同步\n第68条：executor和task优先干线程\n第69条：并发工具优先于wait和notify\n第70条：线程安全性的文档化\n第71条：慎用延迟初始化\n第72条：不要依赖于线程调度器\n第73条：避免使用线程组\n第11章 序列化\n第74条：谨慎地实现Serializable接口\n第75条：考虑使用自定义的序列化形式\n第76条：保护性地编写readObject方法\n第77条：对于实例控制，枚举类型优先于readResolve\n第78条：考虑用序列化代理代替序列化实例\n附录 第1版与第2版条目对照\n中英文术语对照\n参考文献","pages":"287","images":{"small":"https://img3.doubanio.com\/spic\/s3479802.jpg","large":"https://img3.doubanio.com\/lpic\/s3479802.jpg","medium":"https://img3.doubanio.com\/mpic\/s3479802.jpg"},"alt":"https:\/\/book.douban.com\/subject\/3360807\/","id":"3360807","publisher":"机械工业出版社","isbn10":"7111255836","isbn13":"9787111255833","title":"Effective java 中文版（第2版）","url":"https:\/\/api.douban.com\/v2\/book\/3360807","alt_title":"Effective Java Second Edition","author_intro":"Joshua Bloch是Google公司的首席Java架构师。是Jolt大奖的获得者。他曾是Sun公司的杰出工程师，和Transarc公司的高级系统设计师。Bloch曾带领团队设计和实现过无数的Java平台特性，包括JDK 5.0语言增强版和获奖的Java Collections Framework。他的著作还包括：《Java Puzzlers》、《Java Concurrency in Practive》等。","summary":"本书介绍了在Java编程中78条极具实用价值的经验规则，这些经验规则涵盖了大多数开发人员每天所面临的问题的解决方案。通过对Java平台设计专家所使用的技术的全面描述，揭示了应该做什么，不应该做什么才能产生清晰、健壮和高效的代码。\n本书中的每条规则都以简短、独立的小文章形式出现，并通过例子代码加以进一步说明。本书内容全面，结构清晰，讲解详细。可作为技术人员的参考用书。","series":{"id":"28333","title":"Sun公司核心技术丛书"},"price":"52.00元"},{"rating":{"max":10,"numRaters":76,"average":"9.2","min":0},"subtitle":"A Guide to Developing Your Own Java Servlet Container","author":["Budi Kurniawan","Paul Deck"],"pubdate":"2004-4-1","tags":[{"count":137,"name":"Tomcat","title":"Tomcat"},{"count":60,"name":"java","title":"java"},{"count":36,"name":"服务器开源","title":"服务器开源"},{"count":34,"name":"Server","title":"Server"},{"count":25,"name":"Java","title":"Java"},{"count":22,"name":"Web开发","title":"Web开发"},{"count":21,"name":"计算机","title":"计算机"},{"count":20,"name":"web","title":"web"}],"origin_title":"","image":"https://img1.doubanio.com\/mpic\/s4888007.jpg","binding":"Paperback","translator":[],"catalog":"","pages":"458","images":{"small":"https://img1.doubanio.com\/spic\/s4888007.jpg","large":"https://img1.doubanio.com\/lpic\/s4888007.jpg","medium":"https://img1.doubanio.com\/mpic\/s4888007.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1943128\/","id":"1943128","publisher":"BrainySoftware","isbn10":"097521280X","isbn13":"9780975212806","title":"How Tomcat Works","url":"https:\/\/api.douban.com\/v2\/book\/1943128","alt_title":"","author_intro":"","summary":"A Guide to Developing Your Own Java Servlet Container","price":"USD 54.95"},{"rating":{"max":10,"numRaters":554,"average":"8.7","min":0},"subtitle":"","author":["（美）文纳斯"],"pubdate":"2003-9","tags":[{"count":595,"name":"java","title":"java"},{"count":423,"name":"jvm","title":"jvm"},{"count":403,"name":"虚拟机","title":"虚拟机"},{"count":185,"name":"深入Java虚拟机","title":"深入Java虚拟机"},{"count":138,"name":"Java","title":"Java"},{"count":114,"name":"计算机","title":"计算机"},{"count":80,"name":"软件开发","title":"软件开发"},{"count":80,"name":"编程","title":"编程"}],"origin_title":"Inside the Java Virtual Machine","image":"https://img1.doubanio.com\/mpic\/s1106498.jpg","binding":"平装","translator":["曹晓钢","蒋靖"],"catalog":"译者序\n前言\n第1章 Java体系结构介绍\n第2章 平台无关\n第3章 安全\n第4章 网络移动性\n第5章 Java虚拟机\n第6章 Java class文件\n第7章 类型的生命周期\n第8章 连接模型\n第9章 垃圾收集\n第10章 栈和局部变量操作\n第11章 类型转换\n第12章 整数运算\n第13章 逻辑运算\n第14章 浮点运算\n第15章 对象和数组\n第16章 控制流\n第17章 异常\n第18章 finally子句\n第19章 方法的调用与返回\n第20章 指令invokespecial\n第21章 线程同步\n附录A 按操作码助记符排列的指令集\n附录B 按功能排列的操作码助记符\n附录C 按操作码字节值排列的操作码助记符\n附录D Java虚拟机的一个模拟：“Slices of Pi”","pages":"461","images":{"small":"https://img1.doubanio.com\/spic\/s1106498.jpg","large":"https://img1.doubanio.com\/lpic\/s1106498.jpg","medium":"https://img1.doubanio.com\/mpic\/s1106498.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1138768\/","id":"1138768","publisher":"机械工业出版社","isbn10":"7111128052","isbn13":"9787111128052","title":"深入Java虚拟机(原书第2版)","url":"https:\/\/api.douban.com\/v2\/book\/1138768","alt_title":"Inside the Java Virtual Machine","author_intro":"Bill Venners有14年编写软件专著的经验。他在硅谷的Artima软件公司提供软件咨询和培训服务。自1996年以来，他已经编写了40多篇有关Java技术的文章。他在《Java World杂志》辟有热闹专栏，介绍Java内部细节、面向对象设计技术和Jini技术。他还是artima.com的作者和网站管","summary":"本书作者曾因本书荣获专业技术杂志《Java Report》评选的优秀作者奖，细心的读者可以从网上找到许多对本书第1版的赞誉。作者以易于理解的方式深入揭示了Java虚拟机的内部工作原理，深入理解这些内容，将对读者更快速地编写更高效的程序大有裨益！\n本书共分20章，第1-4章解释了Java虚拟机的体系结构，包括Java栈、堆、方法区、执行引擎等；第5-20章深入描述了Java技术的内部细节，包括垃圾收集、Java安全模型、Java的连接模型和动态扩展机制、class文件、运算及流程控制等等，其中第6章和附录A-C安全可以作为class文件和指令集的参考手册。本书还附带光盘，光盘中包含用以辅助说明正文内容的交互式例示applet及示例源代码。","price":"58.00元"},{"rating":{"max":10,"numRaters":124,"average":"9.1","min":0},"subtitle":"Thinking in Java,Third Edition 英文电子版","author":["Bruce Eckel"],"pubdate":"2002-12-06","tags":[{"count":83,"name":"java","title":"java"},{"count":25,"name":"Programming","title":"Programming"},{"count":17,"name":"编程","title":"编程"},{"count":16,"name":"计算机","title":"计算机"},{"count":13,"name":"Java","title":"Java"},{"count":12,"name":"编程语言","title":"编程语言"},{"count":10,"name":"技术","title":"技术"},{"count":7,"name":"thinking","title":"thinking"}],"origin_title":"","image":"https://img1.doubanio.com\/mpic\/s1656369.jpg","binding":"Paperback","translator":[],"catalog":"","pages":"","images":{"small":"https://img1.doubanio.com\/spic\/s1656369.jpg","large":"https://img1.doubanio.com\/lpic\/s1656369.jpg","medium":"https://img1.doubanio.com\/mpic\/s1656369.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1229955\/","id":"1229955","publisher":"Prentice Hall PTR","isbn10":"0131002872","isbn13":"9780131002876","title":"Thinking in Java (3rd Edition)","url":"https:\/\/api.douban.com\/v2\/book\/1229955","alt_title":"","author_intro":"","summary":"Bruce Eckel's Thinking in Java - JavaWorld Editor's Choice Award for Best Book, 2001 JavaWorld Reader's Choice Award for Best Book, 2000 Software Development Magazine Productivity Award, 1999 Java Developer's Journal Editor's Choice Award for Best Book, 1998 Software Development Magazine Jolt Product Excellence Award (for Thinking in C++), 1995 Thinking in Java has earned raves from programmers worldwide for its extraordinary clarity, careful organization, and small, direct programming examples. From the fundamentals of Java syntax to its most advanced features (in-depth object-oriented concepts, multithreading, automated project building, unit testing, and debugging), Thinking in Java is designed to teach, one simple step at a time. The classic Java Introduction, fully updated for Java 2 version 1.4, with new topics throughout! New testing framework validates each program and shows you the output. New chapter on unit testing, automated building, assertions, logging, debugging, and other ways to keep your programs in tune. Completely rewritten threading chapter gives you a solid grasp of the fundamentals. 350+ working Java programs, rewritten for this edition. 15,000+ lines of code. Companion web site includes all source code, annotated solution guide, essays and other resources. Includes entire Foundations for Java multimedia seminar on CD-ROM for Windows, Linux and Mac. For beginners and experts alike. Teaches Java linguistics, not platform-dependent mechanics. Thorough coverage of fundamentals; demonstrates advanced topics. Explains sound object-oriented principles as they apply to Java. Hands-on Java CD available online, with 15 hours of lectures and slides by Bruce Eckel. Live seminars, consulting, and reviews available. www.BruceEckel.com What people are saying- \"The best book on Java...Your depth is amazing.\" \"Definitely the thinking person's choice in a Java book.\" \"One of the absolutely best programming tutorials I've seen, for any language.\" ","price":"USD 54.99"},{"rating":{"max":10,"numRaters":710,"average":"9.0","min":0},"subtitle":"","author":["Brian Goetz","Tim Peierls","Joshua Bloch","Joseph Bowbeer","David Holmes","Doug Lea"],"pubdate":"2012-2","tags":[{"count":1034,"name":"Java","title":"Java"},{"count":842,"name":"并发","title":"并发"},{"count":603,"name":"多线程","title":"多线程"},{"count":263,"name":"编程","title":"编程"},{"count":187,"name":"计算机","title":"计算机"},{"count":186,"name":"java","title":"java"},{"count":96,"name":"软件开发","title":"软件开发"},{"count":94,"name":"线程","title":"线程"}],"origin_title":"Java Concurrency in Practice","image":"https://img3.doubanio.com\/mpic\/s7663093.jpg","binding":"平装","translator":["童云兰"],"catalog":"对本书的赞誉\n译者序\n前　言\n第1章　简介1\n1.1　并发简史1\n1.2　线程的优势2\n1.2.1　发挥多处理器的强大能力2\n1.2.2　建模的简单性3\n1.2.3　异步事件的简化处理3\n1.2.4　响应更灵敏的用户界面4\n1.3　线程带来的风险4\n1.3.1　安全性问题5\n1.3.2　活跃性问题7\n1.3.3　性能问题7\n1.4　线程无处不在7\n第一部分　基础知识\n第2章　线程安全性11\n2.1　什么是线程安全性13\n2.2　原子性14\n2.2.1　竞态条件15\n2.2.2　示例：延迟初始化中的竞态条件16\n2.2.3　复合操作17\n2.3　加锁机制18\n2.3.1　内置锁20\n2.3.2　重入21\n2.4　用锁来保护状态22\n2.5　活跃性与性能23\n第3章　对象的共享27\n3.1　可见性27\n3.1.1　失效数据28\n3.1.2　非原子的64位操作29\n3.1.3　加锁与可见性30\n3.1.4　Volatile变量 30\n3.2　发布与逸出32\n3.3　线程封闭35\n3.3.1　Ad-hoc线程封闭35\n3.3.2　栈封闭36\n3.3.3　ThreadLocal类37\n3.4　不变性38\n3.4.1　Final域39\n3.4.2　示例：使用Volatile类型来发布不可变对象40\n3.5　安全发布41\n3.5.1　不正确的发布：正确的对象被破坏42\n3.5.2 　不可变对象与初始化安全性42\n3.5.3　安全发布的常用模式43\n3.5.4　事实不可变对象44\n3.5.5　可变对象44\n3.5.6　安全地共享对象44\n第4章　对象的组合46\n4.1　设计线程安全的类46\n4.1.1　收集同步需求47\n4.1.2　依赖状态的操作48\n4.1.3　状态的所有权48\n4.2　实例封闭49\n4.2.1　Java监视器模式51\n4.2.2　示例：车辆追踪51\n4.3　线程安全性的委托53\n4.3.1　示例：基于委托的车辆追踪器54\n4.3.2　独立的状态变量55\n4.3.3　当委托失效时56\n4.3.4　发布底层的状态变量57\n4.3.5　示例：发布状态的车辆追踪器58\n4.4　在现有的线程安全类中添加功能59\n4.4.1　客户端加锁机制60\n4.4.2　组合62\n4.5　将同步策略文档化62\n第5章　基础构建模块66\n5.1　同步容器类66\n5.1.1　同步容器类的问题66\n5.1.2　迭代器与Concurrent-ModificationException68\n5.1.3　隐藏迭代器69\n5.2　并发容器70\n5.2.1　ConcurrentHashMap71\n5.2.2　额外的原子Map操作72\n5.2.3　CopyOnWriteArrayList72\n5.3　阻塞队列和生产者-消费者模式73\n5.3.1　示例：桌面搜索75\n5.3.2　串行线程封闭76\n5.3.3　双端队列与工作密取77\n5.4　阻塞方法与中断方法77\n5.5　同步工具类78\n5.5.1　闭锁79\n5.5.2　FutureTask80\n5.5.3　信号量82\n5.5.4　栅栏83\n5.6　构建高效且可伸缩的结果缓存85\n第二部分　结构化并发应用程序\n第6章　任务执行93\n6.1　在线程中执行任务93\n6.1.1　串行地执行任务94\n6.1.2　显式地为任务创建线程94\n6.1.3　无限制创建线程的不足95\n6.2　Executor框架96\n6.2.1　示例：基于Executor的Web服务器97\n6.2.2　执行策略98\n6.2.3　线程池98\n6.2.4　Executor的生命周期99\n6.2.5　延迟任务与周期任务101\n6.3　找出可利用的并行性102\n6.3.1　示例：串行的页面渲染器102\n6.3.2　携带结果的任务Callable与Future103\n6.3.3　示例：使用Future实现页面渲染器104\n6.3.4　在异构任务并行化中存在的局限106\n6.3.5　CompletionService:Executor与BlockingQueue106\n6.3.6　示例：使用CompletionService实现页面渲染器107\n6.3.7　为任务设置时限108\n6.3.8　示例：旅行预定门户网站109\n第7章　取消与关闭111\n7.1　任务取消111\n7.1.1　中断113\n7.1.2　中断策略116\n7.1.3　响应中断117\n7.1.4　示例：计时运行118\n7.1.5　通过Future来实现取消120\n7.1.6　处理不可中断的阻塞121\n7.1.7　采用newTaskFor来封装非标准的取消122\n7.2　停止基于线程的服务124\n7.2.1　示例：日志服务124\n7.2.2　关闭ExecutorService127\n7.2.3　“毒丸”对象128\n7.2.4　示例：只执行一次的服务129\n7.2.5　shutdownNow的局限性130\n7.3　处理非正常的线程终止132\n7.4　JVM关闭135\n7.4.1　关闭钩子135\n7.4.2　守护线程136\n7.4.3　终结器136\n第8章　线程池的使用138\n8.1　在任务与执行策略之间的隐性耦合138\n8.1.1　线程饥饿死锁139\n8.1.2　运行时间较长的任务140\n8.2　设置线程池的大小140\n8.3　配置ThreadPoolExecutor141\n8.3.1　线程的创建与销毁142\n8.3.2　管理队列任务142\n8.3.3　饱和策略144\n8.3.4　线程工厂146\n8.3.5　在调用构造函数后再定制ThreadPoolExecutor147\n8.4　扩展 ThreadPoolExecutor148\n8.5　递归算法的并行化149\n第9章　图形用户界面应用程序156\n9.1　为什么GUI是单线程的156\n9.1.1　串行事件处理157\n9.1.2　Swing中的线程封闭机制158\n9.2　短时间的GUI任务160\n9.3　长时间的GUI任务161\n9.3.1　取消162\n9.3.2　进度标识和完成标识163\n9.3.3　SwingWorker165\n9.4　共享数据模型165\n9.4.1　线程安全的数据模型166\n9.4.2　分解数据模型166\n9.5　其他形式的单线程子系统167\n第三部分　活跃性、性能与测试\n第10章　避免活跃性危险169\n10.1　死锁169\n10.1.1　锁顺序死锁170\n10.1.2　动态的锁顺序死锁171\n10.1.3　在协作对象之间发生的死锁174\n10.1.4　开放调用175\n10.1.5　资源死锁177\n10.2　死锁的避免与诊断178\n10.2.1　支持定时的锁178\n10.2.2　通过线程转储信息来分析死锁178\n10.3　其他活跃性危险180\n10.3.1　饥饿180\n10.3.2　糟糕的响应性181\n10.3.3　活锁181\n第11章　性能与可伸缩性183\n11.1　对性能的思考183\n11.1.1　性能与可伸缩性184\n11.1.2　评估各种性能权衡因素185\n11.2　Amdahl定律186\n11.2.1　示例：在各种框架中隐藏的串行部分188\n11.2.2　Amdahl定律的应用189\n11.3　线程引入的开销189\n11.3.1　上下文切换190\n11.3.2　内存同步190\n11.3.3　阻塞192\n11.4　减少锁的竞争192\n11.4.1　缩小锁的范围（“快进快出”）193\n11.4.2　减小锁的粒度195\n11.4.3　锁分段196\n11.4.4　避免热点域197\n11.4.5　一些替代独占锁的方法198\n11.4.6　监测CPU的利用率199\n11.4.7　向对象池说“不”200\n11.5　示例：比较Map的性能200\n11.6　减少上下文切换的开销201\n第12章　并发程序的测试204\n12.1　正确性测试205\n12.1.1　基本的单元测试206\n12.1.2　对阻塞操作的测试207\n12.1.3　安全性测试208\n12.1.4　资源管理的测试212\n12.1.5　使用回调213\n12.1.6　产生更多的交替操作214\n12.2　性能测试215\n12.2.1　在PutTakeTest中增加计时功能215\n12.2.2　多种算法的比较217\n12.2.3　响应性衡量218\n12.3　避免性能测试的陷阱220\n12.3.1　垃圾回收220\n12.3.2　动态编译220\n12.3.3　对代码路径的不真实采样222\n12.3.4　不真实的竞争程度222\n12.3.5　无用代码的消除223\n12.4　其他的测试方法224\n12.4.1　代码审查224\n12.4.2　静态分析工具224\n12.4.3　面向方面的测试技术226\n12.4.4　分析与监测工具226\n第四部分　高级主题\n第13章　显式锁227\n13.1　Lock与 ReentrantLock227\n13.1.1　轮询锁与定时锁228\n13.1.2　可中断的锁获取操作230\n13.1.3　非块结构的加锁231\n13.2　性能考虑因素231\n13.3　公平性232\n13.4　在synchronized和ReentrantLock之间进行选择234\n13.5　读-写锁235\n第14章　构建自定义的同步工具238\n14.1　状态依赖性的管理238\n14.1.1　示例：将前提条件的失败传递给调用者240\n14.1.2　示例：通过轮询与休眠来实现简单的阻塞241\n14.1.3　条件队列243\n14.2　使用条件队列244\n14.2.1　条件谓词244\n14.2.2　过早唤醒245\n14.2.3　丢失的信号246\n14.2.4　通知247\n14.2.5　示例：阀门类248\n14.2.6　子类的安全问题249\n14.2.7　封装条件队列250\n14.2.8　入口协议与出口协议250\n14.3　显式的Condition对象251\n14.4　Synchronizer剖析253\n14.5　AbstractQueuedSynchronizer254\n14.6　java.util.concurrent同步器类中的 AQS257\n14.6.1　ReentrantLock257\n14.6.2　Semaphore与CountDownLatch258\n14.6.3　FutureTask259\n14.6.4　ReentrantReadWriteLock259\n第15章　原子变量与非阻塞同步机制261\n15.1　锁的劣势261\n15.2　硬件对并发的支持262\n15.2.1　比较并交换263\n15.2.2　非阻塞的计数器264\n15.2.3　JVM对CAS的支持265\n15.3　原子变量类265\n15.3.1　原子变量是一种“更好的volatile”266\n15.3.2　性能比较：锁与原子变量267\n15.4　非阻塞算法270\n15.4.1　非阻塞的栈270\n15.4.2　非阻塞的链表272\n15.4.3　原子的域更新器274\n15.4.4　ABA问题275\n第16章　Java内存模型277\n16.1　什么是内存模型，为什么需要它277\n16.1.1　平台的内存模型278\n16.1.2　重排序278\n16.1.3　Java内存模型简介280\n16.1.4　借助同步281\n16.2　发布283\n16.2.1　不安全的发布283\n16.2.2　安全的发布284\n16.2.3　安全初始化模式284\n16.2.4　双重检查加锁286\n16.3　初始化过程中的安全性287\n附录A　并发性标注289\n参考文献291","pages":"293","images":{"small":"https://img3.doubanio.com\/spic\/s7663093.jpg","large":"https://img3.doubanio.com\/lpic\/s7663093.jpg","medium":"https://img3.doubanio.com\/mpic\/s7663093.jpg"},"alt":"https:\/\/book.douban.com\/subject\/10484692\/","id":"10484692","publisher":"机械工业出版社华章公司","isbn10":"711137004X","isbn13":"9787111370048","title":"Java并发编程实战","url":"https:\/\/api.douban.com\/v2\/book\/10484692","alt_title":"Java Concurrency in Practice","author_intro":"本书作者都是Java Community Process JSR 166专家组（并发工具）的主要成员，并在其他很多JCP专家组里任职。Brian Goetz有20多年的软件咨询行业经验，并著有至少75篇关于Java开发的文章。Tim Peierls是“现代多处理器”的典范，他在BoxPop.biz、唱片艺术和戏剧表演方面也颇有研究。Joseph Bowbeer是一个Java ME专家，他对并发编程的兴趣始于Apollo计算机时代。David Holmes是《The Java Programming Language》一书的合著者，任职于Sun公司。Joshua Bloch是Google公司的首席Java架构师，《Effective Java》一书的作者，并参与著作了《Java Puzzlers》。Doug Lea是《Concurrent Programming》一书的作者，纽约州立大学 Oswego分校的计算机科学教授。","summary":"本书深入浅出地介绍了Java线程和并发，是一本完美的Java并发参考手册。书中从并发性和线程安全性的基本概念出发，介绍了如何使用类库提供的基本并发构建块，用于避免并发危险、构造线程安全的类及验证线程安全的规则，如何将小的线程安全类组合成更大的线程安全类，如何利用线程来提高并发应用程序的吞吐量，如何识别可并行执行的任务，如何提高单线程子系统的响应性，如何确保并发程序执行预期任务，如何提高并发代码的性能和可伸缩性等内容，最后介绍了一些高级主题，如显式锁、原子变量、非阻塞算法以及如何开发自定义的同步工具类。\n本书适合Java程序开发人员阅读。","series":{"id":"38435","title":"华章专业开发者丛书"},"price":"69.00元"},{"rating":{"max":10,"numRaters":108,"average":"6.5","min":0},"subtitle":"改善Java程序的151个建议","author":["秦小波"],"pubdate":"2011-12-28","tags":[{"count":103,"name":"Java","title":"Java"},{"count":42,"name":"编程","title":"编程"},{"count":40,"name":"编写高质量代码","title":"编写高质量代码"},{"count":29,"name":"java","title":"java"},{"count":14,"name":"程序设计","title":"程序设计"},{"count":14,"name":"技术","title":"技术"},{"count":14,"name":"Programming","title":"Programming"},{"count":9,"name":"程序开发","title":"程序开发"}],"origin_title":"","image":"https://img3.doubanio.com\/mpic\/s7015915.jpg","binding":"","translator":[],"catalog":"前言\n第1章　Java开发中通用的方法和准则\/1\n建议1： 不要在常量和变量中出现易混淆的字母\/2\n建议2： 莫让常量蜕变成变量\/2\n建议3： 三元操作符的类型务必一致\/3\n建议4： 避免带有变长参数的方法重载\/4\n建议5： 别让null值和空值威胁到变长方法\/6\n建议6： 覆写变长方法也循规蹈矩\/7\n建议7： 警惕自增的陷阱\/8\n建议8： 不要让旧语法困扰你\/10\n建议9： 少用静态导入\/11\n建议10： 不要在本类中覆盖静态导入的变量和方法\/13\n建议11： 养成良好习惯，显式声明UID\/14\n建议12： 避免用序列化类在构造函数中为不变量赋值\/17\n建议13： 避免为final变量复杂赋值\/19\n建议14： 使用序列化类的私有方法巧妙解决部分属性持久化问题\/20\n建议15： break万万不可忘\/23\n建议16： 易变业务使用脚本语言编写\/25\n建议17： 慎用动态编译\/27\n建议18： 避免instanceof非预期结果\/29\n建议19： 断言绝对不是鸡肋\/31\n建议20： 不要只替换一个类\/33\n第2章　基本类型\/35\n建议21： 用偶判断，不用奇判断\/36\n建议22： 用整数类型处理货币\/37\n建议23： 不要让类型默默转换\/38\n建议24： 边界，边界，还是边界\/39\n建议25： 不要让四舍五入亏了一方\/41\n建议26： 提防包装类型的null值\/43\n建议27： 谨慎包装类型的大小比较\/45\n建议28： 优先使用整型池\/46\n建议29： 优先选择基本类型\/48\n建议30： 不要随便设置随机种子\/49\n第3章　类、对象及方法\/52\n建议31： 在接口中不要存在实现代码\/53\n建议32： 静态变量一定要先声明后赋值\/54\n建议33： 不要覆写静态方法\/55\n建议34： 构造函数尽量简化\/57\n建议35： 避免在构造函数中初始化其他类\/58\n建议36： 使用构造代码块精炼程序\/60\n建议37： 构造代码块会想你所想\/61\n建议38： 使用静态内部类提高封装性\/63\n建议39： 使用匿名类的构造函数\/65\n建议40： 匿名类的构造函数很特殊\/66\n建议41： 让多重继承成为现实\/68\n建议42： 让工具类不可实例化\/70\n建议43： 避免对象的浅拷贝\/71\n建议44： 推荐使用序列化实现对象的拷贝\/73\n建议45： 覆写equals方法时不要识别不出自己\/74\n建议46： equals应该考虑null值情景\/76\n建议47： 在equals中使用getClass进行类型判断\/77\n建议48： 覆写equals方法必须覆写hashCode方法\/78\n建议49： 推荐覆写toString方法\/80\n建议50： 使用package-info类为包服务\/81\n建议51： 不要主动进行垃圾回收\/82\n第4章　字符串\/83\n建议52： 推荐使用String直接量赋值\/84\n建议53： 注意方法中传递的参数要求\/85\n建议54： 正确使用String、StringBuffer、StringBuilder\/86\n建议55： 注意字符串的位置\/87\n建议56： 自由选择字符串拼接方法\/88\n建议57： 推荐在复杂字符串操作中使用正则表达式\/90\n建议58： 强烈建议使用UTF编码\/92\n建议59： 对字符串排序持一种宽容的心态\/94\n第5章　数组和集合\/97\n建议60： 性能考虑，数组是首选\/98\n建议61： 若有必要，使用变长数组\/99\n建议62： 警惕数组的浅拷贝\/100\n建议63： 在明确的场景下，为集合指定初始容量\/101\n建议64： 多种最值算法，适时选择\/104\n建议65： 避开基本类型数组转换列表陷阱\/105\n建议66： asList方法产生的List对象不可更改\/107\n建议67： 不同的列表选择不同的遍历方法\/108\n建议68： 频繁插入和删除时使用LinkedList\/112\n建议69： 列表相等只需关心元素数据\/115\n建议70：子列表只是原列表的一个视图\/117\n建议71： 推荐使用subList处理局部列表\/119\n建议72： 生成子列表后不要再操作原列表\/120\n建议73： 使用Comparator进行排序\/122\n建议74： 不推荐使用binarySearch对列表进行检索\/125\n建议75： 集合中的元素必须做到compareTo和equals同步\/127\n建议76： 集合运算时使用更优雅的方式\/129\n建议77： 使用shuffle打乱列表\/131\n建议78： 减少HashMap中元素的数量\/132\n建议79： 集合中的哈希码不要重复\/135\n建议80： 多线程使用Vector或HashTable\/139\n建议81： 非稳定排序推荐使用List\/141\n建议82： 由点及面，一叶知秋—集合大家族\/143\n第6章　枚举和注解\/145\n建议83： 推荐使用枚举定义常量\/146\n建议84： 使用构造函数协助描述枚举项\/149\n建议85： 小心switch带来的空值异常\/150\n建议86： 在switch的default代码块中增加AssertionError错误\/152\n建议87： 使用valueOf前必须进行校验\/152\n建议88： 用枚举实现工厂方法模式更简洁\/155\n建议89： 枚举项的数量限制在64个以内\/157\n建议90： 小心注解继承\/160\n建议91： 枚举和注解结合使用威力更大\/162\n建议92： 注意@Override不同版本的区别\/164\n第7章　泛型和反射\/166\n建议93： Java的泛型是类型擦除的\/167\n建议94： 不能初始化泛型参数和数组\/169\n建议95： 强制声明泛型的实际类型\/170\n建议96： 不同的场景使用不同的泛型通配符\/172\n建议97： 警惕泛型是不能协变和逆变的\/174\n建议98： 建议采用的顺序是List、List、List\/176\n建议99： 严格限定泛型类型采用多重界限\/177\n建议100： 数组的真实类型必须是泛型类型的子类型\/179\n建议101： 注意Class类的特殊性\/181\n建议102： 适时选择getDeclared×××和get×××\/181\n建议103： 反射访问属性或方法时将Accessible设置为true \/182\n建议104： 使用forName动态加载类文件\/184\n建议105： 动态加载不适合数组\/186\n建议106： 动态代理可以使代理模式更加灵活\/188\n建议107： 使用反射增加装饰模式的普适性\/190\n建议108： 反射让模板方法模式更强大\/192\n建议109： 不需要太多关注反射效率\/194\n第8章　异常\/197\n建议110： 提倡异常封装\/198\n建议111： 采用异常链传递异常\/200\n建议112： 受检异常尽可能转化为非受检异常\/202\n建议113： 不要在finally块中处理返回值\/204\n建议114： 不要在构造函数中抛出异常\/207\n建议115： 使用Throwable获得栈信息\/210\n建议116： 异常只为异常服务\/212\n建议117： 多使用异常，把性能问题放一边\/213\n第9章　多线程和并发\/215\n建议118： 不推荐覆写start方法\/216\n建议119： 启动线程前stop方法是不可靠的\/218\n建议120： 不使用stop方法停止线程\/220\n建议121： 线程优先级只使用三个等级\/224\n建议122： 使用线程异常处理器提升系统可靠性\/226\n建议123： volatile不能保证数据同步\/228\n建议124： 异步运算考虑使用Callable接口\/232\n建议125： 优先选择线程池\/233\n建议126： 适时选择不同的线程池来实现\/237\n建议127： Lock与synchronized是不一样的\/240\n建议128： 预防线程死锁\/245\n建议129： 适当设置阻塞队列长度\/250\n建议130： 使用CountDownLatch协调子线程\/252\n建议131： CyclicBarrier让多线程齐步走\/254\n第10章　性能和效率\/256\n建议132： 提升Java性能的基本方法\/257\n建议133： 若非必要，不要克隆对象\/259\n建议134： 推荐使用“望闻问切”的方式诊断性能\/261\n建议135： 必须定义性能衡量标准\/263\n建议136： 枪打出头鸟—解决首要系统性能问题\/264\n建议137： 调整JVM参数以提升性能\/266\n建议138： 性能是个大“咕咚”\/268\n第11章　开源世界\/271\n建议139： 大胆采用开源工具\/272\n建议140： 推荐使用Guava扩展工具包\/273\n建议141： Apache扩展包\/276\n建议142： 推荐使用Joda日期时间扩展包\/280\n建议143： 可以选择多种Collections扩展\/282\n第12章　思想为源\/285\n建议144： 提倡良好的代码风格\/286\n建议145： 不要完全依靠单元测试来发现问题\/287\n建议146： 让注释正确、清晰、简洁\/290\n建议147： 让接口的职责保持单一\/294\n建议148： 增强类的可替换性\/295\n建议149： 依赖抽象而不是实现\/298\n建议150： 抛弃7条不良的编码习惯\/299\n建议151： 以技术员自律而不是工人\/301","pages":"303","images":{"small":"https://img3.doubanio.com\/spic\/s7015915.jpg","large":"https://img3.doubanio.com\/lpic\/s7015915.jpg","medium":"https://img3.doubanio.com\/mpic\/s7015915.jpg"},"alt":"https:\/\/book.douban.com\/subject\/7059903\/","id":"7059903","publisher":"机械工业出版社华章公司","isbn10":"7111362594","isbn13":"9787111362593","title":"编写高质量代码","url":"https:\/\/api.douban.com\/v2\/book\/7059903","alt_title":"","author_intro":"秦小波，资深软件开发工程师、系统分析师和架构师（获Sun架构师认证），从软件开发工作10余年，实践经验极其丰富。资深Java技术专家，Java语言、Spring、Struts 2、Hibernate、iBatis、jBPM等Java技术，在企业级Java应用领域积累了大量工程经验，对ESB、BPEL等整合技术也有较深入的认识。精通设计模式，对设计模式有深刻的认识和独到见解，而且创造性地提出了自己在大量实践中总结出来的新的设计模式。他撰写的《设计模式之禅》一书凭借优质的内容和良好的可读性广获读者好评，被誉为“设计模式领域的里程碑之作。此外，他还是一位优秀的DBA，具有IBM DB2 DBA资格认证，对海量数据处理有深入的研究。","summary":"在通往“Java技术殿堂”的路上，本书将为你指点迷津！内容全部由Java编码的最佳实践组成，从语法、程序设计和架构、工具和框架、编码风格和编程思想等五大方面对Java程序员遇到的各种棘手的疑难问题给出了经验性的解决方案，为Java程序员如何编写高质量的Java代码提出了151条极为宝贵的建议。对于每一个问题，不仅以建议的方式从正反两面给出了被实践证明为十分优秀的解决方案和非常糟糕的解决方案，而且还分析了问题产生的根源，犹如醍醐灌顶，让人豁然开朗。\n全书一共12章，1~3章针对Java语法本身提出了51条建议，例如覆写变长方法时应该注意哪些事项、final修饰的常量不要在运行期修改、匿名类的构造函数特殊在什么地方等；4~9章重点针对JDK API的使用提出了80条建议，例如字符串的拼接方法该如何选择、枚举使用时有哪些注意事项、出现NullPointerException该如何处理、泛型的多重界限该如何使用、多线程编程如何预防死锁，等等；10~12章针对程序性能、开源的工具和框架、编码风格和编程思想等方面提出了20条建议。\n本书针对每个问题所设计应用场景都非常典型，给出的建议也都与实践紧密结合。书中的每一条建议都可能在你的下一行代码、下一个应用或下一个项目中崭露头角，建议你将此书搁置在手边，随时查阅，一定能使你的学习和开发工作事半功倍。","series":{"id":"19972","title":"实战系列"},"price":"59.00元"},{"rating":{"max":10,"numRaters":139,"average":"9.0","min":0},"subtitle":"Programming Language Guide (Java Series)","author":["Joshua Bloch"],"pubdate":"05 June, 2001","tags":[{"count":95,"name":"Java","title":"Java"},{"count":22,"name":"programming","title":"programming"},{"count":19,"name":"软件开发","title":"软件开发"},{"count":17,"name":"编程","title":"编程"},{"count":17,"name":"effective","title":"effective"},{"count":11,"name":"计算机","title":"计算机"},{"count":9,"name":"程序设计","title":"程序设计"},{"count":7,"name":"高效","title":"高效"}],"origin_title":"","image":"https://img1.doubanio.com\/mpic\/s1408749.jpg","binding":"Paperback","translator":[],"catalog":"","pages":"272","images":{"small":"https://img1.doubanio.com\/spic\/s1408749.jpg","large":"https://img1.doubanio.com\/lpic\/s1408749.jpg","medium":"https://img1.doubanio.com\/mpic\/s1408749.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1246129\/","id":"1246129","publisher":"Addison-Wesley Professional","isbn10":"0201310058","isbn13":"9780201310054","title":"Effective Java","url":"https:\/\/api.douban.com\/v2\/book\/1246129","alt_title":"Effective Java Programming Language Guide","author_intro":"","summary":"Effective Java Programming Language Guide distills the hard-won wisdom of today's best Java programmers into 50 techniques for designing and constructing more robust, high-performance software. Josh Bloch, one of Sun's most widely respected Java developers, focuses on the practical problems virtually every Java developer encounters, offering specific solutions and top-notch code examples. Josh Bloch identifies 50 practices that lead directly to better code -- including better alternatives for common practices that have proven undesirable in real-world development. The techniques are specific, thoroughly explained, and supported by top-notch code examples. Among the highlights: why developers should avoid finalizers; when to use delegation instead of inheritance; and how to make the most of Java's powerful typesafe enum pattern. Nearly all 50 practices relate to the \"core\" of the Java platform -- the language itself -- making the book relevant to virtually every Java developer.","price":"$44.99"},{"rating":{"max":10,"numRaters":148,"average":"7.5","min":0},"subtitle":"Java对象持久化技术详解.","author":["孙卫琴"],"pubdate":"2005-5","tags":[{"count":75,"name":"Hibernate","title":"Hibernate"},{"count":46,"name":"Java","title":"Java"},{"count":17,"name":"orm","title":"orm"},{"count":10,"name":"精通Hibernate","title":"精通Hibernate"},{"count":9,"name":"计算机","title":"计算机"},{"count":9,"name":"j2ee","title":"j2ee"},{"count":8,"name":"OpenSource","title":"OpenSource"},{"count":6,"name":"编程","title":"编程"}],"origin_title":"","image":"https://img3.doubanio.com\/mpic\/s1321842.jpg","binding":"平装","translator":[],"catalog":"第1章 Java对象持久化技术概述\n1.1 应用程序的分层体系结构\n1.2 软件的模型\n1.3 直接通过JDBC API来持久化实体域对象\n1.4 ORM简介\n1.5 实体域对象的其他持久化模式\n1.6 Hibernate API简介\n1.7 小结\n第2章 Hibernate入门\n2.1 创建Hibernate的配置文件46\n2.2 创建持久化类\n2.3 创建数据库Schema\n2.4 创建对象-关系映射文件\n2.5 通过HibernateAPI操纵数据库\n2.6 运行helloapp应用\n2.7 小结\n第3章 hbm2java和hbm2ddl工具\n3.1 创建对象-关系映射文件\n3.2 建立项目的目录结构\n3.3 运行hbm2java工具\n3.4 运行hbm2ddl工具\n3.5 小结\n第4章 对象-关系映射基础\n4.1 持久化类的属性及访问方法\n4.2 处理SQL引用标识符\n4.3 创建命名策略\n4.4 设置命名Schema\n4.5 设置类的包名\n4.6 运行本章的范例程序\n4.7 小结\n第5章 映射对象标识符\n5.1 关系数据库按主键区分不同的记录\n5.2 Java语言按内存地址区分不同的对象\n5.3 Hibernate用对象标识符（OID）来区分对象\n5.4 Hibernate的内置标识符生成器的用法\n5.5 映射自然主键\n5.6 小结\n第6章 映射一对多关联关系\n……\n第7章 操纵持久化对象\n第8章 映射组成关系\n第9章 Hibernate的映射类型\n第10章 Hibernate的检索策略\n第11章 Hibernate的检索方式\n第12章 数据库事务与并发\n第13章 管理Hibernate的缓存\n第14章 映射继承关系\n第15章 Java集合类\n第16章 映射值类型集合\n第17章 映射实体关联关系\n第18章 Hibernate高级配置\n第19章 Hibernate与Struts框架\n第20章 Hibernate与EJB组件\n附录A 标准SQL语言的用法\n附录B Java语言的反射机制\n附录C 用XDoclet工具生成映射文件\n附录D 发布和运行netstore应用\n参考文献","pages":"598","images":{"small":"https://img3.doubanio.com\/spic\/s1321842.jpg","large":"https://img3.doubanio.com\/lpic\/s1321842.jpg","medium":"https://img3.doubanio.com\/mpic\/s1321842.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1315050\/","id":"1315050","publisher":"电子工业出版社","isbn10":"7121011360","isbn13":"9787121011368","title":"精通Hibernate","url":"https:\/\/api.douban.com\/v2\/book\/1315050","alt_title":"","author_intro":"孙卫琴，1997年毕业于上海交通大学，随后一直从事基于Java软件开发工作，2003。年作为访问学者，赴美国参与J2EE项目的研发，在此期间对Java开放源代码项目产生了浓厚的兴趣。2002年开始Java技术领域的图书创作。\n代表著作有：《精通Hiberuate:Java对象持久化技术详解》2005；\n《精通Struts：基于MVC的Java Web设计与开发》2004；《Tomcat与Java Web开发技术详解》2004；《Java 2认证试指南与试题解析》2002。","summary":"Hibernate 是非常流行的对象-关系映射工具。本书详细介绍了运用目前最成熟的 Hibernate 2.1 版本进行 Java 对象持久化的技术。 Hibernate 是连接 Java 对象模型和关系数据模型的桥梁，通过本书，读者不仅能掌握用 Hibernate 工具对这两种模型进行映射的技术，还能获得设计与开发 Java 对象模型和关系数据模型的先进经验。书中内容注重理论与实践相结合，列举了大量具有典型性和实用价值的 Hibernate 应用实例，并提供了详细的开发和部署步骤。随书附赠光盘内容为本书所有范例源程序，以及本书涉及的软件的最新版本的安装程序。\n本书无论对于 Java 开发的新手还是行家来说，都是精通 Java 对象持久化技术的必备实用手册。","price":"59.00元"},{"rating":{"max":10,"numRaters":7,"average":"0.0","min":0},"subtitle":"The Good Parts","author":["Jim Waldo"],"pubdate":"2010-5-9","tags":[{"count":17,"name":"Java","title":"Java"},{"count":4,"name":"编程语言","title":"编程语言"},{"count":4,"name":"O'Reilly","title":"O'Reilly"},{"count":2,"name":"计算机","title":"计算机"},{"count":2,"name":"英文版","title":"英文版"},{"count":2,"name":"编程","title":"编程"},{"count":2,"name":"程序设计","title":"程序设计"},{"count":1,"name":"软件开发","title":"软件开发"}],"origin_title":"","image":"https://img1.doubanio.com\/mpic\/s28362087.jpg","binding":"Paperback","translator":[],"catalog":"","pages":"196","images":{"small":"https://img1.doubanio.com\/spic\/s28362087.jpg","large":"https://img1.doubanio.com\/lpic\/s28362087.jpg","medium":"https://img1.doubanio.com\/mpic\/s28362087.jpg"},"alt":"https:\/\/book.douban.com\/subject\/4822875\/","id":"4822875","publisher":"O'Reilly Media","isbn10":"0596803737","isbn13":"9780596803735","title":"Java","url":"https:\/\/api.douban.com\/v2\/book\/4822875","alt_title":"","author_intro":"","summary":"What if you could condense Java down to its very best features and build better applications with that simpler version? In this book, veteran Sun Labs engineer Jim Waldo reveals which parts of Java are most useful, and why those features make Java among the best programming languages available. Every language eventually builds up crud, Java included. The core language has become increasingly large and complex, and the libraries associated with it have grown even more. Learn how to take advantage of Java's best features by working with an example application throughout the book. You may not like some of the features Jim Waldo considers good, but they'll actually help you write better code. Learn how the type system and packages help you build large-scale software Use exceptions to make code more reliable and easier to maintain Manage memory automatically with garbage collection Discover how the JVM provides portability, security, and nearly bug-free code Use Javadoc to embed documentation within the code Take advantage of reusable data structures in the collections library Use Java RMI to move code and data in a distributed network Learn how Java concurrency constructs let you exploit multicore processors","price":"USD 29.99"},{"rating":{"max":10,"numRaters":723,"average":"8.7","min":0},"subtitle":"基础知识","author":["[美] 霍斯特曼","[美] 科奈尔"],"pubdate":"2006-5","tags":[{"count":558,"name":"JAVA","title":"JAVA"},{"count":204,"name":"编程","title":"编程"},{"count":132,"name":"计算机","title":"计算机"},{"count":107,"name":"JAVA2核心技术","title":"JAVA2核心技术"},{"count":106,"name":"java基础","title":"java基础"},{"count":91,"name":"Java","title":"Java"},{"count":83,"name":"经典","title":"经典"},{"count":79,"name":"程序设计","title":"程序设计"}],"origin_title":"Core java 2. Volume I, Fundamentals","image":"https://img3.doubanio.com\/mpic\/s1815135.jpg","binding":"平装","translator":["叶乃文","邝劲筠 等"],"catalog":"","pages":"691","images":{"small":"https://img3.doubanio.com\/spic\/s1815135.jpg","large":"https://img3.doubanio.com\/lpic\/s1815135.jpg","medium":"https://img3.doubanio.com\/mpic\/s1815135.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1781451\/","id":"1781451","publisher":"机械工业出版社","isbn10":"7111185234","isbn13":"9787111185239","title":"JAVA 2核心技术 卷Ⅰ","url":"https:\/\/api.douban.com\/v2\/book\/1781451","alt_title":"Core java 2. Volume I, Fundamentals","author_intro":"Cay S.Horstmann是圣何塞州立大学计算机科学系教授。他曾经是Preview Systems公司的副总裁和首席技术官，曾任许多大型公司，大学知组织的C++、Java与因特网编程顾问。他还撰写了众多技术和学术专著，并参与编写《Core JavaServer Faces》一书。","summary":"本书是Java技术经典参考书，多年畅销不衰，第7版在保留以前版本风格的基础上，涵盖Java2开发平台标准版J2SE5.0的基础知识，主要内容包括面各对象程序设计、反射与代理、接口与内部类、事件监听器模型、使用Swing UI工具箱进行图形用户界面设计，异常处理、流输入\/输出和对象序列化、泛型程序设计等。\n本书内容翔实、深入浅出，附有大量程序实例，极具实用价值，是Java初学者和Java程序员的必备参考书。","series":{"id":"28333","title":"Sun公司核心技术丛书"},"price":"88.00元"},{"rating":{"max":10,"numRaters":3,"average":"0.0","min":0},"subtitle":"Java","author":["张白一，崔尚森编著"],"pubdate":"2006-1","tags":[{"count":1,"name":"编程语言","title":"编程语言"},{"count":1,"name":"教材","title":"教材"}],"origin_title":"","image":"https://img3.doubanio.com\/mpic\/s11145611.jpg","binding":"","translator":[],"catalog":"","pages":"360","images":{"small":"https://img3.doubanio.com\/spic\/s11145611.jpg","large":"https://img3.doubanio.com\/lpic\/s11145611.jpg","medium":"https://img3.doubanio.com\/mpic\/s11145611.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1725491\/","id":"1725491","publisher":"陕西西安电子科技大学","isbn10":"7560616054","isbn13":"9787560616056","title":"面向对象程序设计-Java","url":"https:\/\/api.douban.com\/v2\/book\/1725491","alt_title":"","author_intro":"","summary":"面向对象程序设计-Java（第二版），ISBN：9787560616056，作者：张白一 等编著","price":"32.00元"},{"rating":{"max":10,"numRaters":33,"average":"7.9","min":0},"subtitle":"Confessions of a Java Framework Architect","author":["Jaroslav Tulach"],"pubdate":"2008-7-29","tags":[{"count":42,"name":"API","title":"API"},{"count":34,"name":"软件设计","title":"软件设计"},{"count":25,"name":"Programming","title":"Programming"},{"count":22,"name":"架构","title":"架构"},{"count":15,"name":"设计","title":"设计"},{"count":13,"name":"设计模式","title":"设计模式"},{"count":8,"name":"软件开发","title":"软件开发"},{"count":8,"name":"计算机","title":"计算机"}],"origin_title":"","image":"https://img3.doubanio.com\/mpic\/s4356554.jpg","binding":"Hardcover","translator":[],"catalog":"","pages":"416","images":{"small":"https://img3.doubanio.com\/spic\/s4356554.jpg","large":"https://img3.doubanio.com\/lpic\/s4356554.jpg","medium":"https://img3.doubanio.com\/mpic\/s4356554.jpg"},"alt":"https:\/\/book.douban.com\/subject\/3178601\/","id":"3178601","publisher":"Apress","isbn10":"1430209739","isbn13":"9781430209737","title":"Practical API Design","url":"https:\/\/api.douban.com\/v2\/book\/3178601","alt_title":"","author_intro":"","summary":"","price":"USD 74.99"}]}

export {data}